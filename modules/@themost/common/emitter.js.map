{"version":3,"sources":["emitter.es6"],"names":["_","async","listenersProperty","Symbol","SequentialEventEmitter","Map","clear","event","callback","has","set","get","push","addListener","type","listeners","index","length","reduce","i","listener","isFunction","splice","isArray","args","self","call","applyEachSeries","err","TypeError","fired","g","removeListener","apply","arguments","on"],"mappings":"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","file":"emitter.js","sourcesContent":["/**\n * @license\n * MOST Web Framework 2.0 Codename Blueshift\n * Copyright (c) 2014, Kyriakos Barbounakis k.barbounakis@gmail.com\n *                     Anthi Oikonomou anthioikonomou@gmail.com\n *\n * Use of this source code is governed by an BSD-3-Clause license that can be\n * found in the LICENSE file at https://themost.io/license\n */\n'use strict';\n\nimport {_} from 'lodash';\nimport async from 'async';\n\nconst listenersProperty = Symbol('listeners');\n\n/**\n * @classdesc SequentialEventEmitter class is an extension of node.js EventEmitter class where listeners are executing in series.\n * @class\n */\nexport class SequentialEventEmitter {\n    /**\n     * @constructor\n     */\n    constructor() {\n        this[listenersProperty] = new Map();\n    }\n\n    removeAllListeners() {\n        this[listenersProperty].clear();\n    }\n\n    /**\n     * Adds the listener function to the end of the listeners array for the specified event\n     * @param {string} event\n     * @param {Function} callback\n     * @returns {SequentialEventEmitter}\n     */\n    addListener(event, callback) {\n        this[listenersProperty].has(event) || this[listenersProperty].set(event, []);\n        this[listenersProperty].get(event).push(callback);\n        return this;\n    }\n\n    /**\n     * Adds the listener function to the end of the listeners array for the specified event\n     * @param {string} event\n     * @param {Function} callback\n     * @returns {SequentialEventEmitter}\n     */\n    on(event, callback) {\n        return this.addListener(event, callback);\n    }\n\n    /**\n     * Removes the specified listener from the listeners array\n     * @param {string} type\n     * @param {Function} callback\n     * @returns {SequentialEventEmitter}\n     */\n    removeListener(type, callback) {\n        let listeners = this[listenersProperty].get(type),\n            index;\n        if (listeners && listeners.length) {\n            index = _.reduce(listeners, (i, listener, index) => {\n                return (_.isFunction(listener) && listener === callback) ?\n                    i = index :\n                    i;\n            }, -1);\n\n            if (index > -1) {\n                listeners.splice(index, 1);\n                this[listenersProperty].set(type, listeners);\n                return this;\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Returns an array of listeners which are listening to the specified event\n     * @param {string} type\n     */\n    listeners(type) {\n        let listeners = this[listenersProperty].get(type);\n        if (typeof listeners === 'undefined') {\n            return [];\n        }\n        if (_.isArray(listeners)) {\n            return listeners;\n        }\n        return [];\n    }\n\n    /**\n     * Returns the number of listeners which are listening to the specified event\n     * @param {string} event\n     */\n    listenerCount(event) {\n        let listeners = this[listenersProperty].get(event);\n        if (_.isArray(listeners)) { return listeners.length; }\n        return 0;\n    }\n\n    /**\n     * Raises the specified event and executes event listeners in series.\n     * @param {String} event - The event that is going to be raised.\n     * @param {*} args - An object that contains the event arguments.\n     * @param {Function} callback - A callback function to be invoked after the execution.\n     */\n    emit(event, args, callback) {\n        const self = this;\n        ////example: call super class function\n        //SequentialEventEmitter.super_.emit.call(this);\n        //ensure callback\n        callback = callback || function() {};\n        //get listeners\n        const listeners = self[listenersProperty].get(event);\n        if (typeof listeners === 'undefined') {\n            return callback.call(self);\n        }\n        //validate listeners\n        if (listeners.length==0) {\n            //exit emitter\n            return callback.call(self);\n        }\n        //apply each series\n        async.applyEachSeries(listeners, args, function(err) {\n            callback.call(self, err);\n        });\n    }\n\n    once(type, listener) {\n        const self = this;\n        if (!_.isFunction(listener))\n            throw TypeError('Listener must be a function');\n        let fired = false;\n        function g() {\n            self.removeListener(type, g);\n            if (!fired) {\n                fired = true;\n                listener.apply(this, arguments);\n            }\n        }\n        g.listener = listener;\n        self.on(type, g);\n        return this;\n    }\n}"]}