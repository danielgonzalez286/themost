{"version":3,"sources":["emitter.es6"],"names":["_","async","listenersProperty","Symbol","SequentialEventEmitter","Map","clear","event","callback","has","set","get","push","addListener","type","listeners","index","length","reduce","i","listener","isFunction","splice","isArray","args","self","bind","applyEachSeries","err","call","TypeError","fired","g","removeListener","apply","arguments","on"],"mappings":"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","file":"emitter.js","sourcesContent":["/**\n * @license\n * MOST Web Framework 2.0 Codename Blueshift\n * Copyright (c) 2017, THEMOST LP All rights reserved\n *\n * Use of this source code is governed by an BSD-3-Clause license that can be\n * found in the LICENSE file at https://themost.io/license\n */\n'use strict';\nimport 'source-map-support/register';\nimport {_} from 'lodash';\nimport async from 'async';\n\nconst listenersProperty = Symbol('listeners');\n\n/**\n * @classdesc SequentialEventEmitter class is an extension of node.js EventEmitter class where listeners are executing in series.\n * @class\n */\nexport class SequentialEventEmitter {\n    /**\n     * @constructor\n     */\n    constructor() {\n        this[listenersProperty] = new Map();\n    }\n\n    removeAllListeners() {\n        this[listenersProperty].clear();\n    }\n\n    /**\n     * Adds the listener function to the end of the listeners array for the specified event\n     * @param {string} event\n     * @param {Function} callback\n     * @returns {SequentialEventEmitter}\n     */\n    addListener(event, callback) {\n        this[listenersProperty].has(event) || this[listenersProperty].set(event, []);\n        this[listenersProperty].get(event).push(callback);\n        return this;\n    }\n\n    /**\n     * Adds the listener function to the end of the listeners array for the specified event\n     * @param {string} event\n     * @param {Function} callback\n     * @returns {SequentialEventEmitter}\n     */\n    on(event, callback) {\n        return this.addListener(event, callback);\n    }\n\n    /**\n     * Removes the specified listener from the listeners array\n     * @param {string} type\n     * @param {Function} callback\n     * @returns {SequentialEventEmitter}\n     */\n    removeListener(type, callback) {\n        let listeners = this[listenersProperty].get(type),\n            index;\n        if (listeners && listeners.length) {\n            index = _.reduce(listeners, (i, listener, index) => {\n                return (_.isFunction(listener) && listener === callback) ?\n                    i = index :\n                    i;\n            }, -1);\n\n            if (index > -1) {\n                listeners.splice(index, 1);\n                //this[listenersProperty].set(type, listeners);\n                return this;\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Returns an array of listeners which are listening to the specified event\n     * @param {string} type\n     */\n    listeners(type) {\n        let listeners = this[listenersProperty].get(type);\n        if (typeof listeners === 'undefined') {\n            return [];\n        }\n        if (_.isArray(listeners)) {\n            return listeners;\n        }\n        return [];\n    }\n\n    /**\n     * Returns the number of listeners which are listening to the specified event\n     * @param {string} event\n     */\n    listenerCount(event) {\n        let listeners = this[listenersProperty].get(event);\n        if (_.isArray(listeners)) { return listeners.length; }\n        return 0;\n    }\n\n    /**\n     * Raises the specified event and executes event listeners in series.\n     * @param {String} event - The event that is going to be raised.\n     * @param {*} args - An object that contains the event arguments.\n     * @param {Function} callback - A callback function to be invoked after the execution.\n     */\n    emit(event, args, callback) {\n        const self = this;\n        ////example: call super class function\n        //SequentialEventEmitter.super_.emit.call(this);\n        //ensure callback\n        callback = callback || function() {};\n        //get listeners\n        const listeners = self[listenersProperty].get(event);\n        if (typeof listeners === 'undefined') {\n            return callback.bind(self)();\n        }\n        //validate listeners\n        if (listeners.length===0) {\n            //exit emitter\n            return callback.bind(self)();\n        }\n        //apply each series\n        try {\n            //apply each series\n            async.applyEachSeries(listeners, args, function(err) {\n                callback.call(self, err);\n            });\n        }\n        catch(err) {\n            return callback.bind(self)(err);\n        }\n\n    }\n\n    once(type, listener) {\n        const self = this;\n        if (!_.isFunction(listener))\n            throw TypeError('Listener must be a function');\n        let fired = false;\n        function g() {\n            self.removeListener(type, g);\n            if (!fired) {\n                fired = true;\n                listener.apply(this, arguments);\n            }\n        }\n        g.listener = listener;\n        self.on(type, g);\n        return this;\n    }\n}"]}