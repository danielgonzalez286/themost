{"version":3,"sources":["expressions.es6"],"names":["_","Operators","Not","Mul","Div","Mod","Add","Sub","Lt","Gt","Le","Ge","Eq","Ne","In","NotIn","And","Or","ArithmeticExpression","p0","oper","p1","left","operator","right","p","Error","exprOf","match","OperatorRegEx","r","result","op","MemberExpression","name","LogicalExpression","args","isArray","length","i","arg","push","LiteralExpression","value","ComparisonExpression","expr","MethodCallExpression","$eq","keys","method","concat","member"],"mappings":"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","file":"expressions.js","sourcesContent":["/**\n * @license\n * MOST Web Framework 2.0 Codename Blueshift\n * Copyright (c) 2014, Kyriakos Barbounakis k.barbounakis@gmail.com\n *                     Anthi Oikonomou anthioikonomou@gmail.com\n *\n * Use of this source code is governed by an BSD-3-Clause license that can be\n * found in the LICENSE file at https://themost.io/license\n */\n'use strict';\nimport 'source-map-support/register';\nimport {_} from 'lodash';\n\nconst Operators = {\n    Not:'$not',\n    // Multiplicative\n    Mul:'$mul',\n    Div:'$div',\n    Mod:'$mod',\n    // Additive\n    Add:'$add',\n    Sub:'$sub',\n    // Relational and type testing\n    Lt:'$lt',\n    Gt:'$gt',\n    Le:'$lte',\n    Ge:'$gte',\n    // Equality\n    Eq:'$eq',\n    Ne:'$ne',\n    // In Values\n    In:'$in',\n    NotIn:'$nin',\n    // Conditional AND\n    And:'$and',\n    // Conditional OR\n    Or:'$or'\n};\n\n/**\n * @class ArithmeticExpression\n * @param {*=} p0 The left operand\n * @param {String=} oper The operator\n * @param {*=} p1 The right operand\n * @constructor\n */\nexport class ArithmeticExpression {\n\n    constructor(p0, oper, p1) {\n        this.left = p0;\n        this.operator = oper || '$add';\n        this.right = p1;\n    }\n\n    /**\n     * @param {*=} left The left operand\n     * @param {String=} operator The operator\n     * @param {*=} right The right operand\n     * @returns ArithmeticExpression\n     */\n    static create(left, operator, right) {\n        return new ArithmeticExpression(left, operator, right);\n    }\n    /**\n     * Gets a boolean value that indicates whether or not the given operator is an arithmetic operator.\n     * @param {String} op\n     */\n    static isArithmeticOperator(op) {\n        if (typeof op === 'string')\n            return (op.match(ArithmeticExpression.OperatorRegEx)!==null);\n        return false;\n    }\n\n    exprOf() {\n        let p;\n        if (typeof this.left === 'undefined' || this.left===null)\n            throw new Error('Expected left operand');\n        else if (typeof this.left.exprOf === 'function')\n            p = this.left.exprOf();\n        else\n            p = this.left;\n        if (typeof this.operator === 'undefined' || this.operator===null)\n            throw new Error('Expected arithmetic operator.');\n        if (this.operator.match(ArithmeticExpression.OperatorRegEx)===null)\n            throw new Error('Invalid arithmetic operator.');\n        //build right operand e.g. { $add:[ 5 ] }\n        const r = {};\n        if (typeof this.right === 'undefined' || this.right===null)\n            r[this.operator]=[null];\n        else if (typeof this.right.exprOf === 'function')\n            r[this.operator] = [this.right.exprOf()];\n        else\n            r[this.operator]=[this.right];\n        //add left operand e.g { Price: { $add:[ 5 ] } }\n        const result = {};\n        result[p] = r;\n        //return query expression\n        return result;\n    }\n}\n\nArithmeticExpression.OperatorRegEx = /^(\\$add|\\$sub|\\$mul|\\$div|\\$mod)$/g;\n\n/**\n * @class MemberExpression\n * @param {String} name The name of the current member\n * @constructor\n */\nexport class MemberExpression {\n    constructor(name) {\n        this.name = name;\n    }\n\n    exprOf() {\n        return this.name;\n    }\n\n    /**\n     * @param {String=} name A string that represents the member's name\n     * @returns MemberExpression\n     */\n    static create(name) {\n        return new MemberExpression(name);\n    }\n}\n\n/**\n * @class LogicalExpression\n * @param {String} name The name of the current member\n * @constructor\n */\nexport class LogicalExpression {\n    constructor(oper, args) {\n        this.operator = oper || '$and' ;\n        this.args = args || [];\n    }\n\n    /**\n     * Creates a logical expression\n     * @param {String} operator The logical operator\n     * @param {Array} args An array that represents the expression's arguments\n     * @returns {LogicalExpression}\n     */\n    static create(operator, args) {\n        return new LogicalExpression(operator, args);\n    }\n\n    /**\n     * Gets a boolean value that indicates whether or not the given operator is a logical operator.\n     * @param {String} op The current operator\n     */\n    static isLogicalOperator(op) {\n        if (typeof op === 'string')\n            return (op.match(LogicalExpression.OperatorRegEx)!==null);\n        return false;\n    }\n\n    exprOf() {\n        if (this.operator.match(LogicalExpression.OperatorRegEx)===null)\n            throw new Error('Invalid logical operator.');\n        if (!_.isArray(this.args))\n            throw new Error('Logical expression arguments cannot be null at this context.');\n        if (this.args.length===0)\n            throw new Error('Logical expression arguments cannot be empty.');\n        const p = {};\n        p[this.operator] = [];\n        for (let i = 0; i < this.args.length; i++) {\n            const arg = this.args[i];\n            if (typeof arg === 'undefined' || arg===null)\n                p[this.operator].push(null);\n            else if (typeof arg.exprOf === 'function')\n                p[this.operator].push(arg.exprOf());\n            else\n                p[this.operator].push(arg);\n        }\n        return p;\n    }\n}\n\nLogicalExpression.OperatorRegEx = /^(\\$and|\\$or|\\$not|\\$nor)$/g;\n\n/**\n * @class LiteralExpression\n * @param {*} value The literal value\n * @constructor\n */\nexport class LiteralExpression {\n\n    constructor(value) {\n        this.value = value;\n    }\n\n    /**\n     * Creates a literal expression\n     * @param {*=} value The literal value\n     * @returns LiteralExpression\n     */\n    static create(value) {\n        return new LiteralExpression(value);\n    }\n\n    exprOf() {\n        if (typeof this.value === 'undefined')\n            return null;\n        return this.value;\n    }\n}\n\n/**\n *\n * @param {*} left\n * @param {String=} op\n * @param {*=} right\n * @constructor\n */\nexport class ComparisonExpression {\n\n    constructor(left, op, right) {\n        this.left = left;\n        this.operator = op || '$eq';\n        this.right = right;\n    }\n\n    /**\n     * Creates a comparison expression\n     * @param {*=} left The left operand\n     * @param {String=} operator The operator\n     * @param {*=} right The right operand\n     * @returns ComparisonExpression\n     */\n    static create(left, operator, right) {\n        return new ComparisonExpression(left, operator, right);\n    }\n\n    /**\n     * Gets a boolean value that indicates whether or not the given operator is an arithmetic operator.\n     * @param {String} op\n     */\n    static isComparisonOperator(op) {\n        if (typeof op === 'string')\n            return (op.match(ComparisonExpression.OperatorRegEx)!==null);\n        return false;\n    }\n\n    exprOf() {\n        let p, name, expr;\n        if (typeof this.operator === 'undefined' || this.operator===null)\n            throw new Error('Expected comparison operator.');\n\n        if (this.left instanceof MethodCallExpression)\n        {\n            p = {};\n            if (typeof this.right === 'undefined' || this.right===null)\n                p[this.operator]=null;\n            else if (typeof this.right.exprOf === 'function')\n                p[this.operator] = this.right.exprOf();\n            else\n                p[this.operator]=this.right;\n\n            if (this.operator==='$eq')\n                this.left.args.push(p.$eq);\n            else\n                this.left.args.push(p);\n            //return query expression\n            return this.left.exprOf();\n        }\n        else if (this.left instanceof ArithmeticExpression)\n        {\n            p = {};\n            //build comparison expression e.g. { $gt:10 }\n            if (typeof this.right === 'undefined' || this.right===null)\n                p[this.operator]=null;\n            else if (typeof this.right.exprOf === 'function')\n                p[this.operator] = this.right.exprOf();\n            else\n                p[this.operator]=this.right;\n\n            //get left expression\n            expr = this.left.exprOf();\n            //find argument list\n            name = _.keys(expr)[0];\n            if (this.operator==='$eq')\n                expr[name][this.left.operator].push(p.$eq);\n            else\n                expr[name][this.left.operator].push(p);\n            //return query expression\n            return expr;\n        }\n        else if (this.left instanceof MemberExpression)\n        {\n            p = {};\n            //build comparison expression e.g. { $gt:10 }\n            if (typeof this.right === 'undefined' || this.right===null)\n                p[this.operator]=null;\n            else if (typeof this.right.exprOf === 'function')\n                p[this.operator] = this.right.exprOf();\n            else\n                p[this.operator]=this.right;\n            name = this.left.name;\n            expr = {};\n            if (this.operator==='$eq')\n                expr[name]=p.$eq;\n            else\n                expr[name] = p;\n            //return query expression\n            return expr;\n        }\n    }\n}\n\nComparisonExpression.OperatorRegEx = /^(\\$eq|\\$ne|\\$lte|\\$lt|\\$gte|\\$gt|\\$in|\\$nin)$/g;\n\n/**\n * Creates a method call expression\n * @class MethodCallExpression\n * @constructor\n */\nexport class MethodCallExpression {\n    constructor(name, args) {\n        /**\n         * Gets or sets the name of this method\n         * @type {String}\n         */\n        this.name = name;\n        /**\n         * Gets or sets an array that represents the method arguments\n         * @type {Array}\n         */\n        this.args = [];\n        if (_.isArray(args))\n            this.args = args;\n    }\n\n    /**\n     * Creates a method call expression of the given name with an array of arguments\n     * @param {String} name\n     * @param {Array} args\n     * @returns {MethodCallExpression}\n     */\n    static create(name, args) {\n        return new MethodCallExpression(name, args);\n    }\n\n    /**\n     * Converts the current method to the equivalent query expression e.g. { orderDate: { $year: [] } } which is equivalent with year(orderDate)\n     * @returns {*}\n     */\n    exprOf() {\n        const method = {};\n        const result = {};\n        const name = '$'.concat(this.name);\n        //set arguments array\n        method[name] = [] ;\n        if (this.args.length===0)\n            throw new Error('Unsupported method expression. Method arguments cannot be empty.');\n        //get first argument\n        if (this.args[0] instanceof MemberExpression) {\n            const member = this.args[0].name;\n            for (let i = 1; i < this.args.length; i++)\n            {\n                const arg = this.args[i];\n                if (typeof arg === 'undefined' || arg===null)\n                    method[name].push(null);\n                else if (typeof arg.exprOf === 'function')\n                    method[name].push(arg.exprOf());\n                else\n                    method[name].push(arg);\n            }\n            result[member] = method;\n            return result;\n        }\n        else {\n            throw new Error('Unsupported method expression. The first argument of a method expression must be always a MemberExpression.');\n        }\n\n    }\n}"]}