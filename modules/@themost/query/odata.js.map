{"version":3,"sources":["odata.es6"],"names":["sprintf","ArithmeticExpression","ComparisonExpression","LogicalExpression","MemberExpression","MethodCallExpression","OpenDataParser","current","offset","source","tokens","currentToken","undefined","nextToken","previousToken","self","Object","defineProperty","get","length","configurable","enumerable","token","type","Token","TokenType","Identifier","identifier","Operator","And","Or","Eq","Ne","Lt","Le","Gt","Ge","In","NotIn","Add","Sub","Mul","Div","Mod","Not","str","callback","call","toList","parseCommon","err","result","exprOf","e","valueOf","Error","moveNext","atEnd","parseCommonItem","syntax","SyntaxToken","Comma","ParenClose","op","getOperator","right","expr","createExpression","isLogicalOperator","op2","err2","expr2","left","operator","create","i","args","o","push","isComparisonOperator","ParenOpen","parseMethodCall","parseMember","Slash","Literal","value","Syntax","Negative","expect","method","parseMethodCallArguments","resolveMethod","expectAny","arguments","resolveMember","member","getNext","_current","_source","_offset","isWhitespace","charAt","c","parseSign","parseString","parseSyntax","isDigit","parseNumeric","isIdentifierStartChar","parseIdentifier","minus","isIdentifierChar","name","substr","trim","lastOffset","LiteralToken","PositiveInfinity","NegativeInfinity","NaN","True","False","Null","stringType","StringType","Binary","DateTime","Guid","Time","DateTimeOffset","None","content","parseSpecialString","IdentifierToken","match","GuidRegex","LiteralType","DurationRegex","negative","year","parseInt","month","day","hour","minute","second","parseFloat","TimeSpan","Duration","parseDateTimeString","DateTimeRegex","Date","parseBinaryString","parseDateTimeOffsetString","parseGuidString","parseTimeString","hadEnd","sb","String","floating","CHR_POINT","haveExponent","exponentEnd","skipDigits","text","Single","Double","Decimal","Long","Int","REGEXP_CHAR","REGEXP_DIGIT","CHR_UNDERSCORE","CHR_DOLLARSIGN","isChar","CHR_WHITESPACE","ArithmeticOperatorRegEx","LogicalOperatorRegEx","tokenType","literalType","Boolean","chr"],"mappings":"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","file":"odata.js","sourcesContent":["/**\n * @license\n * MOST Web Framework 2.0 Codename Blueshift\n * Copyright (c) 2014, Kyriakos Barbounakis k.barbounakis@gmail.com\n *                     Anthi Oikonomou anthioikonomou@gmail.com\n *\n * Use of this source code is governed by an BSD-3-Clause license that can be\n * found in the LICENSE file at https://themost.io/license\n */\nimport 'source-map-support/register';\nimport sprintf from 'sprintf';\nimport {ArithmeticExpression, ComparisonExpression, LogicalExpression, MemberExpression,\n    MethodCallExpression\n} from './expressions'; \n\n\n/**\n * @class OpenDataParser\n * @constructor\n */\nexport class OpenDataParser {\n\n    constructor() {\n\n        /**\n         * @type {number}\n         * @private\n         */\n        this.current = 0;\n        /**\n         * @type {number}\n         * @private\n         */\n        this.offset = 0;\n        /**\n         * @type {string}\n         */\n        this.source = null;\n        /**\n         * @type {Array}\n         */\n        this.tokens = [];\n        /**\n         * Gets current token\n         * @type {Token}\n         */\n        this.currentToken = undefined;\n        /**\n         * Gets next token\n         * @type {Token}\n         */\n        this.nextToken = undefined;\n        /**\n         * Gets previous token\n         * @type {Token}\n         */\n        this.previousToken = undefined;\n\n        const self = this;\n        Object.defineProperty(this,'nextToken', {\n            get:function() {\n                return (self.offset < self.tokens.length - 1) ? self.tokens[self.offset+1] : null;\n            },\n            configurable:false, enumerable:false\n        });\n\n        Object.defineProperty(this,'previousToken', {\n            get:function() {\n                return ((self.offset > 0) && (self.tokens.length>0)) ? self.tokens[self.offset-1] : null;\n            },\n            configurable:false, enumerable:false\n        });\n\n        Object.defineProperty(this,'currentToken', {\n            get:function() {\n                return (self.offset < self.tokens.length) ? self.tokens[self.offset] : null;\n            },\n            configurable:false, enumerable:false\n        });\n\n    }\n\n    create() {\n        return new OpenDataParser();\n    }\n\n    /**\n     * Gets the logical or artihmetic operator of the given token\n     * @param token\n     */\n    getOperator(token) {\n        if (token.type===Token.TokenType.Identifier) {\n            switch (token.identifier)\n            {\n            case \"and\": return Token.Operator.And;\n            case \"or\": return Token.Operator.Or;\n            case \"eq\": return Token.Operator.Eq;\n            case \"ne\": return Token.Operator.Ne;\n            case \"lt\": return Token.Operator.Lt;\n            case \"le\": return Token.Operator.Le;\n            case \"gt\": return Token.Operator.Gt;\n            case \"ge\": return Token.Operator.Ge;\n            case \"in\": return Token.Operator.In;\n            case \"nin\": return Token.Operator.NotIn;\n            case \"add\": return Token.Operator.Add;\n            case \"sub\": return Token.Operator.Sub;\n            case \"mul\": return Token.Operator.Mul;\n            case \"div\": return Token.Operator.Div;\n            case \"mod\": return Token.Operator.Mod;\n            case \"not\": return Token.Operator.Not;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Parses an open data filter and returns the equivalent query expression\n     * @param {string} str\n     * @param {Function} callback\n     */\n    parse(str, callback) {\n        const self = this;\n        //ensure callback\n        callback = callback || function() {};\n        if (typeof str !== 'string')\n        {\n            callback.call(this);\n            return;\n        }\n        /**\n         * @private\n         * @type {number}\n         */\n        this.current = 0;\n        /**\n         * @private\n         * @type {number}\n         */\n        this.offset = 0;\n        /**\n         * Gets or sets the source expression that is going to be parsed\n         * @type {String}\n         */\n        this.source = str;\n        //get tokens\n        this.tokens = this.toList();\n        //reset offset\n        this.offset=0; this.current=0;\n        //invoke callback\n        this.parseCommon(function(err, result)\n        {\n            try {\n                if (result) {\n                    if (typeof result.exprOf === 'function') {\n                        return callback.call(self, err, result.exprOf());\n                    }\n                }\n                callback.call(self, err, result);\n            }\n            catch(e) {\n                callback.call(self, e);\n            }\n        });\n\n    }\n\n    moveNext() {\n        this.offset++;\n    }\n\n    /**\n     * @param {Token} token\n     */\n    expect(token) {\n        const self = this;\n        if (self.currentToken.valueOf()!==token.valueOf())\n            throw new Error(sprintf.sprintf('Expected %s.', token.valueOf()));\n        this.moveNext();\n    }\n\n    expectAny() {\n        if (this.atEnd())\n            throw new Error('Unexpected end.');\n    }\n\n    atEnd() {\n        return this.offset >= this.tokens.length;\n    }\n\n    atStart() {\n        return this.offset === 0;\n    }\n\n    /**\n     * Parses OData token\n     * @param {Function} callback\n     */\n    parseCommon(callback) {\n        const self = this;\n        //ensure callback\n        callback = callback || function() {};\n        if (this.tokens.length===0) {\n            callback.call(self);\n            return;\n        }\n        self.parseCommonItem(function(err, result) {\n            if (err) {\n                callback.call(self, err);\n            }\n            else {\n                if (this.atEnd()) {\n                    callback.call(self, null, result);\n                }\n                //method call exception for [,] or [)] tokens e.g indexOf(Title,'...')\n                else if ((this.currentToken.syntax===SyntaxToken.Comma.syntax) ||\n                    (this.currentToken.syntax===SyntaxToken.ParenClose.syntax)) {\n                    callback.call(self, null, result);\n                }\n                else {\n                    const op = this.getOperator(self.currentToken);\n                    if (op===null) {\n                        callback.call(self, new Error('Expected operator.'));\n                    }\n                    else {\n                        this.moveNext();\n                        this.parseCommonItem(function(err, right) {\n                            if (err) {\n                                callback.call(self, err);\n                            }\n                            else {\n                                //create odata expression\n                                const expr = self.createExpression(result, op, right);\n                                if (!self.atEnd() && (LogicalExpression.isLogicalOperator(self.getOperator(self.currentToken)))) {\n                                    const op2 = self.getOperator(self.currentToken);\n                                    self.moveNext();\n                                    return self.parseCommon(function(err2, expr2) {\n                                        if (err2) {\n                                            callback(err2);\n                                        }\n                                        else {\n                                            callback.call(self, null, self.createExpression(expr, op2, expr2));\n                                        }\n                                    });\n                                }\n                                callback.call(self, null, expr);\n                            }\n                        });\n                    }\n                }\n            }\n        });\n    }\n\n    /**\n     * @param {*=} left The left operand\n     * @param {String=} operator The operator\n     * @param {*=} right The right operand\n     */\n    createExpression(left, operator, right) {\n        let expr = null;\n        if (LogicalExpression.isLogicalOperator(operator))\n        {\n            if (left instanceof LogicalExpression)\n            {\n                if (left.operator===operator) {\n                    expr = LogicalExpression.create(operator);\n                    for (let i = 0; i < left.args.length; i++) {\n                        const o = left.args[i];\n                        expr.args.push(o);\n                    }\n                    expr.args.push(right);\n                }\n                else {\n                    expr = LogicalExpression.create(operator, [left, right]);\n                }\n            }\n            else\n            {\n                expr = LogicalExpression.create(operator, [left, right]);\n            }\n            return expr;\n        }\n        else if (LogicalExpression.isLogicalOperator(operator)) {\n            return ArithmeticExpression.create(left, operator, right);\n        }\n        else if ((left instanceof ArithmeticExpression) || (left instanceof MethodCallExpression) || (left instanceof MemberExpression))  {\n            expr = ComparisonExpression.create(left, operator, right);\n            return expr;\n        }\n        else if (ComparisonExpression.isComparisonOperator(operator)) {\n            return ComparisonExpression.create(left,operator, right);\n        }\n        else {\n            throw new Error('Invalid or unsupported expression arguments.');\n        }\n    }\n\n    /**\n     * \n     * @param {Function} callback\n     */\n    parseCommonItem(callback) {\n        const self = this;\n        //ensure callback\n        callback = callback || function() {};\n        if (self.tokens.length===0) {\n            callback.call(self);\n            return;\n        }\n        switch (this.currentToken.type) {\n        case Token.TokenType.Identifier:\n            //if next token is an open parenthesis token and the current token is not an operator. current=indexOf, next=(\n            if ((self.nextToken.syntax===SyntaxToken.ParenOpen.syntax) && (self.getOperator(self.currentToken)===null))\n            {\n                //then parse method call\n                self.parseMethodCall(callback);\n            }\n            else if (self.getOperator(self.currentToken) === Token.Operator.Not)\n            {\n                callback.call(self,new Error('Not operator is not yet implemented.'));\n                return;\n            }\n            else\n            {\n                self.parseMember(function(err, result) {\n                    if (err) {\n                        callback.call(self,err);\n                    }\n                    else {\n                        while (!self.atEnd() && self.currentToken.syntax===SyntaxToken.Slash.syntax) {\n                            //self.moveNext();\n                            //self.parseMembers(callback)\n                            callback.call(self,new Error('Slash syntax is not yet implemented.'));\n                        }\n                    }\n                    self.moveNext();\n                    callback.call(self, null, result);\n                });\n\n            }\n            break;\n        case Token.TokenType.Literal:\n            const value = self.currentToken.value;\n            self.moveNext();\n            callback.call(self, null, value);\n            break;\n        case Token.TokenType.Syntax:\n            if (self.currentToken.syntax === SyntaxToken.Negative.syntax) {\n                callback.call(self,new Error('Negative syntax is not yet implemented.'));\n                return;\n            }\n            if (self.currentToken.syntax === SyntaxToken.ParenOpen.syntax) {\n                self.moveNext();\n                self.parseCommon(function(err, result) {\n                    if (err) {\n                        return callback(err);\n                    }\n                    else {\n                        self.expect(SyntaxToken.ParenClose);\n                        callback.call(self, null, result);\n                    }\n                });\n            }\n            else {\n                callback.call(self,new Error('Expected syntax.'));\n                return;\n            }\n            break;\n        default:break;\n        }\n\n    }\n\n    parseMethodCall(callback) {\n        const self = this;\n        //ensure callback\n        callback = callback || function() {};\n        if (this.tokens.length===0)\n            callback.call(this);\n        else\n        {\n            //get method name\n            const method = self.currentToken.identifier;\n            self.moveNext();\n            self.expect(SyntaxToken.ParenOpen);\n            const args = [];\n            self.parseMethodCallArguments(args, function(err, result) {\n                if (err) {\n                    callback.call(self, err);\n                }\n                else {\n                    self.resolveMethod(method, args, function(err, expr) {\n                        if (err) {\n                            callback.call(self, err);\n                        }\n                        else {\n                            if (typeof expr === 'undefined' || expr === null)\n                                callback.call(self, null, MethodCallExpression.create(method, args));\n                            else\n                                callback.call(self, null, expr);\n                        }\n                    });\n\n                }\n            });\n        }\n    }\n\n    parseMethodCallArguments(args, callback) {\n        const self = this;\n        //ensure callback\n        callback = callback || function() {};\n        args = args || [];\n        self.expectAny();\n        if (self.currentToken.syntax===SyntaxToken.Comma.syntax) {\n            self.moveNext();\n            self.expectAny();\n            self.parseMethodCallArguments(args, callback);\n        }\n        else if (self.currentToken.syntax===SyntaxToken.ParenClose.syntax) {\n            self.moveNext();\n            callback(null, arguments);\n        }\n        else {\n            self.parseCommon(function(err, result) {\n                if (err) {\n                    callback(err);\n                }\n                else {\n                    args.push(result);\n                    self.parseMethodCallArguments(args, callback);\n                }\n            });\n        }\n\n    }\n    /**\n     *\n     * @param {Function} callback\n     */\n    parseMember(callback) {\n        const self = this;\n        //ensure callback\n        callback = callback || function() {};\n        if (this.tokens.length===0) {\n            callback.call(this);\n        }\n        else {\n            if (this.currentToken.type!=='Identifier') {\n                callback.call(self, new Error('Expected identifier.'));\n            }\n            else {\n                let identifier = this.currentToken.identifier;\n                while (this.nextToken.syntax===SyntaxToken.Slash.syntax) {\n                    //read syntax token\n                    this.moveNext();\n                    //get next token\n                    if (this.nextToken.type !== 'Identifier')\n                        callback.call(self, new Error('Expected identifier.'));\n                    //read identifier token\n                    this.moveNext();\n                    //format identifier\n                    identifier += '/' + this.currentToken.identifier;\n                }\n                //search for multiple nested member expression (e.g. a/b/c)\n\n                self.resolveMember(identifier, function(err, member) {\n                    callback.call(self, err,new MemberExpression(member));\n                });\n            }\n        }\n    }\n\n    /**\n     * Abstract function which resolves entity based on the given member name\n     * @param {string} member\n     * @param {Function} callback\n     */\n    resolveMember(member, callback) {\n        if (typeof callback !== 'function')\n            //sync process\n            return member;\n        else\n            callback.call(this, null, member);\n    }\n\n    /**\n     * Resolves a custom method of the given name and arguments and returns an equivalent MethodCallExpression instance.\n     * @param method\n     * @param args\n     * @param {Function} callback\n     * @returns {MethodCallExpression}\n     */\n    resolveMethod(method, args, callback) {\n        if (typeof callback !== 'function')\n            //sync process\n            return null;\n        else\n            callback.call(this);\n    }\n\n    ///**\n    // * Resolves an equivalent expressiob based on the given OData token\n    // * @param {Token} token\n    // */\n    //OpenDataParser.prototype.resolveVariable = function(token, callback) {\n    //    return null;\n    //};\n\n    /**\n     * Get a collection of tokens by parsing the curent expression\n     * @returns {Array}\n     */\n    toList() {\n        if (typeof this.source !== 'string')\n            return [];\n        this.current = 0;\n        this.offset = 0;\n        const result = [];\n        let token;\n        while ((token = this.getNext()) !== null)\n        {\n            result.push(token);\n        }\n        return result;\n    }\n\n    /**\n     * @returns Token\n     */\n    getNext() {\n        let _current = this.current;\n        const _source = this.source;\n        let _offset = this.offset;\n\n        if (_offset >= _source.length)\n            return null;\n\n        while (_offset < _source.length && OpenDataParser.isWhitespace(_source.charAt(_offset)))\n        {\n            _offset++;\n        }\n        if (_offset >= _source.length)\n            return null;\n        _current = _offset;\n        this.current = _current;\n        const c = _source.charAt(_current);\n        switch (c)\n        {\n        case '-':\n            return this.parseSign();\n\n        case '\\'':\n            return this.parseString(0);\n\n        case '(':\n        case ')':\n        case ',':\n        case '/':\n            return this.parseSyntax();\n        default:\n            if (OpenDataParser.isDigit(c))\n            {\n                return this.parseNumeric();\n            }\n            else if (OpenDataParser.isIdentifierStartChar(c))\n            {\n                return this.parseIdentifier(false);\n            }\n            else\n            {\n                throw new Error(sprintf.sprintf('Unexpecter character \"%s\" at offset %s.', c , _current));\n            }\n        }\n    }\n\n    /**\n     * @returns {Token}\n     */\n    parseSyntax() {\n        /**\n         * @type {Token}\n         */\n        let token = null;\n        switch (this.source.charAt(this.current))\n        {\n        case '(': token = SyntaxToken.ParenOpen; break;\n        case ')': token = SyntaxToken.ParenClose; break;\n        case '/': token = SyntaxToken.Slash; break;\n        case ',': token = SyntaxToken.Comma; break;\n        default : throw new Error('Unknown token');\n        }\n        this.offset = this.current + 1;\n\n        return token;\n    }\n\n    /**\n     * @returns {Token}\n     */\n    parseIdentifier(minus) {\n        let _current = this.current;\n        const _source = this.source;\n        let _offset = this.offset;\n\n        for (_current++; _current < _source.length; _current++)\n        {\n            const c = _source.charAt(_current);\n            if (OpenDataParser.isIdentifierChar(c)===false)\n                break;\n        }\n\n        const name = _source.substr(_offset, _current - _offset).trim();\n\n        const lastOffset = _offset;\n        _offset = _current;\n        switch (name)\n        {\n        case \"INF\":\n            this.current = _current;this.offset=_offset;\n            return LiteralToken.PositiveInfinity;\n\n        case \"-INF\":\n            this.current = _current;this.offset=_offset;\n            return LiteralToken.NegativeInfinity;\n\n        case \"Nan\":\n            this.current = _current;this.offset=_offset;\n            return LiteralToken.NaN;\n\n        case \"true\":\n            this.current = _current;this.offset=_offset;\n            return LiteralToken.True;\n\n        case \"false\":\n            this.current = _current;this.offset=_offset;\n            return LiteralToken.False;\n\n        case \"null\":\n            this.current = _current;this.offset=_offset;\n            return LiteralToken.Null;\n\n        case \"-\":\n            this.current = _current;this.offset=_offset;\n            return SyntaxToken.Negative;\n\n        default:\n            if (minus) {\n                // Reset the offset.\n                _offset = lastOffset + 1;\n                this.current = _current;this.offset=_offset;\n                return SyntaxToken.Negative;\n            }\n            this.current = _current;this.offset=_offset;\n            break;\n        }\n        if ((_offset < _source.length) && (_source.charAt(_offset) === '\\''))\n        {\n            let stringType;\n            switch (name)\n            {\n            case \"X\": stringType = LiteralToken.StringType.Binary; break;\n            case \"binary\": stringType = LiteralToken.StringType.Binary; break;\n            case \"datetime\": stringType = LiteralToken.StringType.DateTime; break;\n            case \"guid\": stringType = LiteralToken.StringType.Guid; break;\n            case \"time\": stringType = LiteralToken.StringType.Time; break;\n            case \"datetimeoffset\": stringType = LiteralToken.StringType.DateTimeOffset; break;\n            default: stringType = LiteralToken.StringType.None; break;\n            }\n\n            if (stringType !== LiteralToken.StringType.None && _source.charAt(_offset) === '\\'')\n            {\n                const content = this.parseString();\n                return this.parseSpecialString(content.value, stringType);\n            }\n        }\n        return new IdentifierToken(name);\n    }\n\n    /**\n     * Parses a guid string and returns an open data token.\n     * @returns Token\n     */\n    parseGuidString(value) {\n        if (typeof value !== 'string')\n            throw new Error(sprintf.sprintf('Invalid argument at %s.', this.offset));\n        if (value.match(OpenDataParser.GuidRegex)!==null)\n            throw new Error(sprintf.sprintf('Guid format is invalid at %s.', this.offset));\n        return new LiteralToken(value, LiteralToken.LiteralType.Guid);\n    }\n\n    /**\n     * Parses a time string and returns an open data token.\n     * @returns Token\n     */\n    parseTimeString(value) {\n        if (typeof value === 'undefined' || value===null)\n            return null;\n        const match = value.match(OpenDataParser.DurationRegex);\n        if (match!==null)\n        {\n            const negative = (match[1] === \"-\");\n            const year = match[2].length > 0 ? parseInt(match[2]) : 0, month = match[3].length > 0 ? parseInt(match[3]) : 0, day = match[4].length > 0 ? parseInt(match[4]) : 0, hour = match[5].length > 0 ? parseInt(match[5]) : 0, minute = match[6].length > 0 ? parseInt(match[6]) : 0, second = match[7].length > 0 ? parseFloat(match[7]) : 0;\n            return new LiteralToken(new TimeSpan(!negative, year, month, day, hour, minute, second), LiteralToken.LiteralType.Duration);\n        }\n        else\n        {\n            throw new Error(sprintf.sprintf('Duration format is invalid at %s.', this.offset))\n        }\n    }\n\n    /**\n     * Parses a date time offset string and returns an open data token\n     * @param value\n     * @returns {LiteralToken}\n     */\n    parseBinaryString(value) {\n        throw new Error('Not Implemented');\n    }\n\n    /**\n     * Parses a date time offset string and returns an open data token\n     * @param value\n     * @returns {LiteralToken}\n     */\n    parseDateTimeOffsetString(value) {\n        return this.parseDateTimeString(value);\n    }\n\n    /**\n     * Parses a date time string and returns an open data token\n     * @param value\n     * @returns {LiteralToken}\n     */\n    parseDateTimeString(value) {\n        if (typeof value === 'undefined' || value===null)\n            return null;\n        const match = value.match(OpenDataParser.DateTimeRegex);\n        if (match!==null)\n        {\n            const year = parseInt(match[1]);\n            const month = parseInt(match[2]);\n            const day = parseInt(match[3]);\n            const hour = parseInt(match[4]);\n            const minute = parseInt(match[5]);\n            const second = match[6].length > 0 ? parseInt(match[6]) : 0;\n            //const nanoSecond = match[7].length > 0 ? parseInt(match[7]) : 0;\n            return new LiteralToken(new Date(year, month, day, hour, minute, second), LiteralToken.LiteralType.DateTime);\n        }\n        else\n        {\n            throw new Error(sprintf.sprintf('Datetime format is invalid at %s.', this.offset))\n        }\n    }\n\n    /**\n     * @returns Token\n     */\n    parseSpecialString(value, stringType) {\n        switch (stringType)\n        {\n        case LiteralToken.StringType.Binary:\n            return this.parseBinaryString(value);\n\n        case LiteralToken.StringType.DateTime:\n            return this.parseDateTimeString(value);\n\n        case LiteralToken.StringType.DateTimeOffset:\n            return this.parseDateTimeOffsetString(value);\n\n        case LiteralToken.StringType.Guid:\n            return this.parseGuidString(value);\n\n        case LiteralToken.StringType.Time:\n            return this.parseTimeString(value);\n\n        default:\n            throw new Error('Argument stringType was out of range.');\n        }\n    }\n\n    /**\n     * @returns {Token}\n     */\n    parseString() {\n        let hadEnd = false;\n        let _current = this.current;\n        const _source = this.source;\n        const _offset = this.offset;\n        let sb = '';\n        for (_current++; _current < _source.length; _current++)\n        {\n            const c = this.source.charAt(_current);\n\n            if (c === '\\'')\n            {\n                if ((_current < _source.length - 1) && (_source.charAt(_current+1) === '\\'')) {\n                    _current++;\n                    sb += '\\'';\n                }\n                else\n                {\n                    hadEnd = true;\n                    break;\n                }\n            }\n            else\n            {\n                sb +=c;\n            }\n        }\n\n        if (!hadEnd)\n        {\n            throw new Error(sprintf.sprintf('Unterminated string starting at %s', _offset));\n        }\n        this.current = _current;\n        this.offset = _current + 1;\n        return new LiteralToken(sb, LiteralToken.LiteralType.String);\n    }\n\n    skipDigits(current) {\n        const _source = this.source;\n        if (!OpenDataParser.isDigit(_source.charAt(current)))\n            return null;\n        current++;\n        while (current < _source.length && OpenDataParser.isDigit(_source.charAt(current))) {\n            current++;\n        }\n        return current;\n    }\n\n    /**\n     * @returns {Token}\n     */\n    parseNumeric() {\n        let _current = this.current;\n        const _source = this.source;\n        let _offset = this.offset;\n        let floating = false;\n        let c = null;\n\n        for (_current++; _current < _source.length; _current++)\n        {\n            c = _source.charAt(_current);\n            if (c === OpenDataParser.CHR_POINT)\n            {\n                if (floating)\n                    break;\n                floating = true;\n            }\n            else if (!OpenDataParser.isDigit(c))\n            {\n                break;\n            }\n        }\n        let haveExponent = false;\n        if (_current < _source.length)\n        {\n            c = _source.charAt(_current);\n            if (c === 'E' || c === 'e')\n            {\n                _current++;\n                if (_source.charAt(_current) === '-')\n                    _current++;\n                const exponentEnd = (_current === _source.length) ? null : this.skipDigits(_current);\n                if (exponentEnd===null)\n                    throw new Error(sprintf.sprintf('Expected digits after exponent at %s.', _offset));\n                _current = exponentEnd;\n                haveExponent = true;\n\n                if (_current < _source.length) {\n                    c = _source.charAt(_current);\n                    if (c === 'm' || c === 'M')\n                        throw new Error(sprintf.sprintf('Unexpected exponent for decimal literal at %s.', _offset));\n                    else if (c === 'l' || c === 'L')\n                        throw new Error(sprintf.sprintf('Unexpected exponent for long literal at %s.', _offset));\n                }\n            }\n        }\n\n        const text = _source.substr(_offset, _current - _offset);\n        let value = null;\n        let type = null;\n\n        if (_current < _source.length)\n        {\n            c = _source.charAt(_current);\n\n            switch (c)\n            {\n            case 'F':\n            case 'f':\n                value = parseFloat(text);\n                type = LiteralToken.LiteralType.Single;\n                _current++;\n                break;\n\n            case 'D':\n            case 'd':\n                value = parseFloat(text);\n                type = LiteralToken.LiteralType.Double;\n                _current++;\n                break;\n\n            case 'M':\n            case 'm':\n                value = parseFloat(text);\n                type = LiteralToken.LiteralType.Decimal;\n                _current++;\n                break;\n\n            case 'L':\n            case 'l':\n                value = parseInt(text);\n                type = LiteralToken.LiteralType.Long;\n                _current++;\n                break;\n\n            default:\n                if (floating || haveExponent)\n                {\n                    value = parseFloat(text);\n                    type = LiteralToken.LiteralType.Double;\n                }\n                else\n                {\n                    value = parseInt(text);\n                    type = LiteralToken.LiteralType.Int;\n                }\n                break;\n            }\n        }\n        else\n        {\n            if (floating || haveExponent)\n            {\n                value = parseFloat(text);\n                type = LiteralToken.LiteralType.Double;\n            }\n            else\n            {\n                value = parseInt(text);\n                type = LiteralToken.LiteralType.Int;\n            }\n        }\n\n        _offset = _current;\n        this.offset = _offset;\n        this.current = _current;\n        return new LiteralToken(value, type);\n    }\n\n    /**\n     * @returns {Token}\n     */\n    parseSign() {\n        this.current++;\n        if (OpenDataParser.isDigit(this.source.charAt(this.current)))\n            return this.parseNumeric();\n        else\n            return this.parseIdentifier(true);\n    }\n\n    /**\n     * @param {String} c\n     * @returns {boolean}\n     */\n    static isChar(c) {\n        return (c.match(OpenDataParser.REGEXP_CHAR)!==null);\n    }\n\n    /**\n     * @param {String} c\n     * @returns {boolean}\n     */\n    static isDigit(c) {\n        return (c.match(OpenDataParser.REGEXP_DIGIT)!==null);\n    }\n\n    static isIdentifierStartChar(c) {\n        return (c === OpenDataParser.CHR_UNDERSCORE) || (c === OpenDataParser.CHR_DOLLARSIGN) || OpenDataParser.isChar(c);\n    }\n\n    /**\n      * @param {String} c\n     * @returns {boolean}\n     */\n    static isWhitespace(c) {\n        return (c === OpenDataParser.CHR_WHITESPACE);\n    }\n\n    static isIdentifierChar(c) {\n        return OpenDataParser.isIdentifierStartChar(c) || OpenDataParser.isDigit(c);\n    }\n}\n\nOpenDataParser.ArithmeticOperatorRegEx = /^(\\$add|\\$sub|\\$mul|\\$div|\\$mod)$/g;\nOpenDataParser.LogicalOperatorRegEx = /^(\\$or|\\$nor|\\$not|\\$and)$/g;\n\nOpenDataParser.DurationRegex = /^(-)?P(?:(\\\\d+)Y)?(?:(\\\\d+)M)?(?:(\\\\d+)D)?T?(?:(\\\\d+)H)?(?:(\\\\d+)M)?(?:(\\\\d+(?:\\\\.\\\\d*)?)S)?$/g;\nOpenDataParser.GuidRegex = /^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/g;\nOpenDataParser.DateTimeRegex = /^(\\\\d{4})-(\\\\d{1,2})-(\\\\d{1,2})T(\\\\d{1,22}):(\\\\d{2})(?::(\\\\d{2})(?:\\\\.(\\\\d{7}))?)?$/g;\n\nOpenDataParser.REGEXP_CHAR = /[a-zA-Z]/g;\nOpenDataParser.REGEXP_DIGIT = /[0-9]/g;\nOpenDataParser.CHR_WHITESPACE = ' ';\nOpenDataParser.CHR_UNDERSCORE = '_';\nOpenDataParser.CHR_DOLLARSIGN = '$';\nOpenDataParser.CHR_POINT = '.';\n\nclass TimeSpan {\n    toString() {\n\n    }\n}\n\n/**\n * @class Token\n * @abstract Toke\n * @param {String} tokenType\n * @constructor\n */\nexport class Token {\n    constructor(tokenType) {\n        this.type = tokenType;\n    }\n\n    isParenOpen() {\n        return (this.type==='Syntax') && (this.syntax==='(');\n    }\n\n    isParenClose() {\n        return (this.type==='Syntax') && (this.syntax===')');\n    }\n\n    isSlash() {\n        return (this.type==='Syntax') && (this.syntax==='/');\n    }\n\n    isComma() {\n        return (this.type==='Syntax') && (this.syntax===',');\n    }\n\n    isNegative() {\n        return (this.type==='Syntax') && (this.syntax==='-');\n    }\n}\n\nToken.TokenType = {\n    Literal : 'Literal',\n    Identifier: 'Identifier',\n    Syntax: 'Syntax'\n};\n\nToken.Operator ={\n    Not:'$not',\n    // Multiplicative\n    Mul:'$mul',\n    Div:'$div',\n    Mod:'$mod',\n    // Additive\n    Add:'$add',\n    Sub:'$sub',\n    // Relational and type testing\n    Lt:'$lt',\n    Gt:'$gt',\n    Le:'$lte',\n    Ge:'$gte',\n    // Equality\n    Eq:'$eq',\n    Ne:'$ne',\n    // In Values\n    In:'$in',\n    NotIn:'$nin',\n    // Conditional AND\n    And:'$and',\n    // Conditional OR\n    Or:'$or'\n};\n\n\n/**\n * @class LiteralToken\n * @param {*} value\n * @param {String} literalType\n * @constructor\n */\nexport class LiteralToken extends Token {\n    constructor(value, literalType) {\n        super(Token.TokenType.Literal);\n        this.value = value;\n        this.literalType = literalType;\n    }\n}\n\nLiteralToken.LiteralType = {\n    Null: 'Null',\n    String: 'String',\n    Boolean: 'Boolean',\n    Single: 'Single',\n    Double: 'Double',\n    Decimal: 'Decimal',\n    Int: 'Int',\n    Long: 'Long',\n    Binary: 'Binary',\n    DateTime: 'DateTime',\n    Guid: 'Guid',\n    Duration:'Duration'\n};\n\nLiteralToken.StringType =\n{\n    None:'None',\n    Binary:'Binary',\n    DateTime:'DateTime',\n    Guid:'Guid',\n    Time:'Time',\n    DateTimeOffset:'DateTimeOffset'\n};\n\nLiteralToken.PositiveInfinity = new LiteralToken(NaN, LiteralToken.LiteralType.Double);\nLiteralToken.NegativeInfinity = new LiteralToken(NaN, LiteralToken.LiteralType.Double);\nLiteralToken.NaN = new LiteralToken(NaN, LiteralToken.LiteralType.Double);\nLiteralToken.True = new LiteralToken(true, LiteralToken.LiteralType.Boolean);\nLiteralToken.False = new LiteralToken(false, LiteralToken.LiteralType.Boolean);\nLiteralToken.Null = new LiteralToken(null, LiteralToken.LiteralType.Null);\n\n\n/**\n * @class IdentifierToken\n * @param {String} The identifier's name\n * @constructor\n */\nexport class IdentifierToken extends Token {\n    constructor(name) {\n        super(Token.TokenType.Identifier);\n        this.identifier = name;\n    }\n\n    valueOf() {\n        return this.identifier;\n    }\n}\n\n/**\n * @class SyntaxToken\n * @param {String} chr\n * @constructor\n */\nexport class SyntaxToken extends Token {\n    constructor(chr) {\n        super(Token.TokenType.Syntax);\n        this.syntax = chr;\n    }\n\n    valueOf() {\n        return this.syntax;\n    }\n}\n\nSyntaxToken.ParenOpen = new SyntaxToken('(');\nSyntaxToken.ParenClose = new SyntaxToken(')');\nSyntaxToken.Slash = new SyntaxToken('/');\nSyntaxToken.Comma = new SyntaxToken(',');\nSyntaxToken.Negative = new SyntaxToken('-');"]}