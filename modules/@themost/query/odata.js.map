{"version":3,"sources":["odata.es6"],"names":["sprintf","ArithmeticExpression","ComparisonExpression","LiteralExpression","LogicalExpression","MemberExpression","MethodCallExpression","OpenDataParser","current","offset","source","tokens","currentToken","undefined","nextToken","previousToken","self","Object","defineProperty","get","length","configurable","enumerable","token","type","Token","TokenType","Identifier","identifier","Operator","And","Or","Eq","Ne","Lt","Le","Gt","Ge","In","NotIn","Add","Sub","Mul","Div","Mod","Not","str","callback","call","toList","parseCommon","err","result","exprOf","e","valueOf","Error","moveNext","atEnd","parseCommonItem","syntax","SyntaxToken","Comma","ParenClose","op","getOperator","right","expr","createExpression","isLogicalOperator","op2","err2","expr2","left","operator","create","i","args","o","push","isComparisonOperator","ParenOpen","parseMethodCall","parseMember","Slash","Literal","value","Syntax","Negative","expect","method","parseMethodCallArguments","resolveMethod","expectAny","arguments","resolveMember","member","getNext","_current","_source","_offset","isWhitespace","charAt","c","parseSign","parseString","parseSyntax","isDigit","parseNumeric","isIdentifierStartChar","parseIdentifier","minus","isIdentifierChar","name","substr","trim","lastOffset","LiteralToken","PositiveInfinity","NegativeInfinity","NaN","True","False","Null","stringType","StringType","Binary","DateTime","Guid","Time","DateTimeOffset","None","content","parseSpecialString","IdentifierToken","match","GuidRegex","LiteralType","DurationRegex","negative","year","parseInt","month","day","hour","minute","second","parseFloat","TimeSpan","Duration","parseDateTimeString","DateTimeRegex","nanoSecond","Date","parseBinaryString","parseDateTimeOffsetString","parseGuidString","parseTimeString","hadEnd","sb","String","floating","CHR_POINT","haveExponent","exponentEnd","skipDigits","text","Single","Double","Decimal","Long","Int","REGEXP_CHAR","REGEXP_DIGIT","CHR_UNDERSCORE","CHR_DOLLARSIGN","isChar","CHR_WHITESPACE","ArithmeticOperatorRegEx","LogicalOperatorRegEx","tokenType","literalType","Boolean","chr"],"mappings":"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","file":"odata.js","sourcesContent":["/**\n * @license\n * MOST Web Framework 2.0 Codename Blueshift\n * Copyright (c) 2014, Kyriakos Barbounakis k.barbounakis@gmail.com\n *                     Anthi Oikonomou anthioikonomou@gmail.com\n *\n * Use of this source code is governed by an BSD-3-Clause license that can be\n * found in the LICENSE file at https://themost.io/license\n */\n'use strict';\nimport sprintf from 'sprintf';\nimport {ArithmeticExpression, ComparisonExpression, LiteralExpression, LogicalExpression, MemberExpression,\n    MethodCallExpression\n} from './expressions'; \n\n\n/**\n * @class OpenDataParser\n * @constructor\n */\nexport class OpenDataParser {\n\n    constructor() {\n\n        /**\n         * @type {number}\n         * @private\n         */\n        this.current = 0;\n        /**\n         * @type {number}\n         * @private\n         */\n        this.offset = 0;\n        /**\n         * @type {string}\n         */\n        this.source = null;\n        /**\n         * @type {Array}\n         */\n        this.tokens = [];\n        /**\n         * Gets current token\n         * @type {Token}\n         */\n        this.currentToken = undefined;\n        /**\n         * Gets next token\n         * @type {Token}\n         */\n        this.nextToken = undefined;\n        /**\n         * Gets previous token\n         * @type {Token}\n         */\n        this.previousToken = undefined;\n\n        const self = this;\n        Object.defineProperty(this,'nextToken', {\n            get:function() {\n                return (self.offset < self.tokens.length - 1) ? self.tokens[self.offset+1] : null;\n            },\n            configurable:false, enumerable:false\n        });\n\n        Object.defineProperty(this,'previousToken', {\n            get:function() {\n                return ((self.offset > 0) && (self.tokens.length>0)) ? self.tokens[self.offset-1] : null;\n        },\n        configurable:false, enumerable:false\n        });\n\n        Object.defineProperty(this,'currentToken', {\n            get:function() {\n                return (self.offset < self.tokens.length) ? self.tokens[self.offset] : null;\n        },\n        configurable:false, enumerable:false\n        });\n\n    }\n\n    create() {\n        return new OpenDataParser();\n    }\n\n    /**\n     * Gets the logical or artihmetic operator of the given token\n     * @param token\n     */\n    getOperator(token) {\n        if (token.type==Token.TokenType.Identifier) {\n            switch (token.identifier)\n            {\n                case \"and\": return Token.Operator.And;\n                case \"or\": return Token.Operator.Or;\n                case \"eq\": return Token.Operator.Eq;\n                case \"ne\": return Token.Operator.Ne;\n                case \"lt\": return Token.Operator.Lt;\n                case \"le\": return Token.Operator.Le;\n                case \"gt\": return Token.Operator.Gt;\n                case \"ge\": return Token.Operator.Ge;\n                case \"in\": return Token.Operator.In;\n                case \"nin\": return Token.Operator.NotIn;\n                case \"add\": return Token.Operator.Add;\n                case \"sub\": return Token.Operator.Sub;\n                case \"mul\": return Token.Operator.Mul;\n                case \"div\": return Token.Operator.Div;\n                case \"mod\": return Token.Operator.Mod;\n                case \"not\": return Token.Operator.Not;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Parses an open data filter and returns the equivalent query expression\n     * @param {string} str\n     * @param {Function} callback\n     */\n    parse(str, callback) {\n        const self = this;\n        //ensure callback\n        callback = callback || function() {};\n        if (typeof str !== 'string')\n        {\n            callback.call(this);\n            return;\n        }\n        /**\n         * @private\n         * @type {number}\n         */\n        this.current = 0;\n        /**\n         * @private\n         * @type {number}\n         */\n        this.offset = 0;\n        /**\n         * Gets or sets the source expression that is going to be parsed\n         * @type {String}\n         */\n        this.source = str;\n        //get tokens\n        this.tokens = this.toList();\n        //reset offset\n        this.offset=0; this.current=0;\n        //invoke callback\n        this.parseCommon(function(err, result)\n        {\n            try {\n                if (result) {\n                    if (typeof result.exprOf === 'function') {\n                        return callback.call(self, err, result.exprOf());\n                    }\n                }\n                callback.call(self, err, result);\n            }\n            catch(e) {\n                callback.call(self, e);\n            }\n        });\n\n    }\n\n    moveNext() {\n       this.offset++;\n    }\n\n    /**\n     * @param {Token} token\n     */\n    expect(token) {\n        const self = this;\n        if (self.currentToken.valueOf()!==token.valueOf())\n            throw new Error(sprintf.sprintf('Expected %s.', token.valueOf()));\n        this.moveNext();\n    }\n\n    expectAny() {\n        if (this.atEnd())\n            throw new Error('Unexpected end.');\n    }\n\n    atEnd() {\n        return this.offset >= this.tokens.length;\n    }\n\n    atStart() {\n        return this.offset == 0;\n    }\n\n    /**\n     * Parses OData token\n     * @param {Function} callback\n     */\n    parseCommon(callback) {\n        const self = this;\n        //ensure callback\n        callback = callback || function() {};\n        if (this.tokens.length==0) {\n            callback.call(self);\n            return;\n        }\n        self.parseCommonItem(function(err, result) {\n            if (err) {\n                callback.call(self, err);\n            }\n            else {\n                if (this.atEnd()) {\n                    callback.call(self, null, result);\n                }\n                //method call exception for [,] or [)] tokens e.g indexOf(Title,'...')\n                else if ((this.currentToken.syntax==SyntaxToken.Comma.syntax) ||\n                    (this.currentToken.syntax==SyntaxToken.ParenClose.syntax)) {\n                    callback.call(self, null, result);\n                }\n                else {\n                    const op = this.getOperator(self.currentToken);\n                    if (op==null) {\n                        callback.call(self, new Error('Expected operator.'));\n                    }\n                    else {\n                        this.moveNext();\n                        this.parseCommonItem(function(err, right) {\n                            if (err) {\n                                callback.call(self, err);\n                            }\n                            else {\n                                //create odata expression\n                                const expr = self.createExpression(result, op, right);\n                                if (!self.atEnd() && (LogicalExpression.isLogicalOperator(self.getOperator(self.currentToken)))) {\n                                    const op2 = self.getOperator(self.currentToken);\n                                    self.moveNext();\n                                    return self.parseCommon(function(err2, expr2) {\n                                        if (err2) {\n                                            callback(err2);\n                                        }\n                                        else {\n                                            callback.call(self, null, self.createExpression(expr, op2, expr2));\n                                        }\n                                    });\n                                }\n                                callback.call(self, null, expr);\n                            }\n                        });\n                    }\n                }\n            }\n        });\n    }\n\n    /**\n     * @param {*=} left The left operand\n     * @param {String=} operator The operator\n     * @param {*=} right The right operand\n     */\n    createExpression(left, operator, right) {\n        let expr = null;\n        if (LogicalExpression.isLogicalOperator(operator))\n        {\n            if (left instanceof LogicalExpression)\n            {\n                if (left.operator==operator) {\n                    expr = LogicalExpression.create(operator);\n                    for (let i = 0; i < left.args.length; i++) {\n                        const o = left.args[i];\n                        expr.args.push(o);\n                    }\n                    expr.args.push(right);\n                }\n                else {\n                    expr = LogicalExpression.create(operator, [left, right]);\n                }\n            }\n            else\n            {\n                expr = LogicalExpression.create(operator, [left, right]);\n            }\n            return expr;\n        }\n        else if (LogicalExpression.isLogicalOperator(operator)) {\n            return ArithmeticExpression.create(left, operator, right);\n        }\n        else if ((left instanceof ArithmeticExpression) || (left instanceof MethodCallExpression) || (left instanceof MemberExpression))  {\n                expr = ComparisonExpression.create(left, operator, right);\n                return expr;\n        }\n        else if (ComparisonExpression.isComparisonOperator(operator)) {\n            return ComparisonExpression.create(left,operator, right);\n        }\n        else {\n            throw new Error('Invalid or unsupported expression arguments.');\n        }\n    }\n\n    /**\n     * \n     * @param {Function} callback\n     */\n    parseCommonItem(callback) {\n        const self = this;\n        //ensure callback\n        callback = callback || function() {};\n        if (self.tokens.length==0) {\n            callback.call(self);\n            return;\n        }\n        switch (this.currentToken.type) {\n            case Token.TokenType.Identifier:\n                //if next token is an open parenthesis token and the current token is not an operator. current=indexOf, next=(\n                if ((self.nextToken.syntax==SyntaxToken.ParenOpen.syntax) && (self.getOperator(self.currentToken)==null))\n                {\n                    //then parse method call\n                    self.parseMethodCall(callback);\n                }\n                else if (self.getOperator(self.currentToken) == Token.Operator.Not)\n                {\n                    callback.call(self,new Error('Not operator is not yet implemented.'));\n                    return;\n                }\n                else\n                {\n                    self.parseMember(function(err, result) {\n                        if (err) {\n                            callback.call(self,err);\n                        }\n                        else {\n                            while (!self.atEnd() && self.currentToken.syntax==SyntaxToken.Slash.syntax) {\n                                //self.moveNext();\n                                //self.parseMembers(callback)\n                                callback.call(self,new Error('Slash syntax is not yet implemented.'));\n                            }\n                        }\n                        self.moveNext();\n                        callback.call(self, null, result);\n                    });\n\n                }\n                break;\n            case Token.TokenType.Literal:\n                const value = self.currentToken.value;\n                self.moveNext();\n                callback.call(self, null, value);\n                break;\n            case Token.TokenType.Syntax:\n                if (self.currentToken.syntax == SyntaxToken.Negative.syntax) {\n                    callback.call(self,new Error('Negative syntax is not yet implemented.'));\n                    return;\n                }\n                if (self.currentToken.syntax == SyntaxToken.ParenOpen.syntax) {\n                    self.moveNext();\n                    self.parseCommon(function(err, result) {\n                        if (err) {\n                            callback.call(self, err);\n                        }\n                        else {\n                            self.expect(SyntaxToken.ParenClose);\n                            callback.call(self, null, result);\n                        }\n                    });\n                }\n                else {\n                    callback.call(self,new Error('Expected syntax.'));\n                    return;\n                }\n                break;\n            default:break;\n        }\n\n    }\n\n    parseMethodCall(callback) {\n        const self = this;\n        //ensure callback\n        callback = callback || function() {};\n        if (this.tokens.length==0)\n            callback.call(this);\n        else\n        {\n            //get method name\n            const method = self.currentToken.identifier;\n            self.moveNext();\n            self.expect(SyntaxToken.ParenOpen);\n            const args = [];\n            self.parseMethodCallArguments(args, function(err, result) {\n                if (err) {\n                    callback.call(self, err);\n                }\n                else {\n                    self.resolveMethod(method, args, function(err, expr) {\n                       if (err) {\n                           callback.call(self, err);\n                       }\n                       else {\n                           if (typeof expr === 'undefined' || expr == null)\n                               callback.call(self, null, MethodCallExpression.create(method, args));\n                           else\n                               callback.call(self, null, expr);\n                       }\n                    });\n\n                }\n            });\n        }\n    }\n\n    parseMethodCallArguments(args, callback) {\n        const self = this;\n        //ensure callback\n        callback = callback || function() {};\n        args = args || [];\n        self.expectAny();\n        if (self.currentToken.syntax==SyntaxToken.Comma.syntax) {\n            self.moveNext();\n            self.expectAny();\n            self.parseMethodCallArguments(args, callback);\n        }\n        else if (self.currentToken.syntax==SyntaxToken.ParenClose.syntax) {\n            self.moveNext();\n            callback(null, arguments);\n        }\n        else {\n            self.parseCommon(function(err, result) {\n                if (err) {\n                    callback(err);\n                }\n                else {\n                    args.push(result);\n                    self.parseMethodCallArguments(args, callback);\n                }\n            });\n        }\n\n    }\n    /**\n     *\n     * @param {Function} callback\n     */\n    parseMember(callback) {\n        const self = this;\n        //ensure callback\n        callback = callback || function() {};\n        if (this.tokens.length==0) {\n            callback.call(this);\n        }\n        else {\n            if (this.currentToken.type!='Identifier') {\n                callback.call(self, new Error('Expected identifier.'));\n            }\n            else {\n                let identifier = this.currentToken.identifier;\n                while (this.nextToken.syntax==SyntaxToken.Slash.syntax) {\n                    //read syntax token\n                    this.moveNext();\n                    //get next token\n                    if (this.nextToken.type !== 'Identifier')\n                        callback.call(self, new Error('Expected identifier.'));\n                    //read identifier token\n                    this.moveNext();\n                    //format identifier\n                    identifier += '/' + this.currentToken.identifier;\n                }\n                //search for multiple nested member expression (e.g. a/b/c)\n\n                self.resolveMember(identifier, function(err, member) {\n                    callback.call(self, err,new MemberExpression(member));\n                });\n            }\n        }\n    }\n\n    /**\n     * Abstract function which resolves entity based on the given member name\n     * @param {string} member\n     * @param {Function} callback\n     */\n    resolveMember(member, callback) {\n        if (typeof callback !== 'function')\n            //sync process\n            return member;\n        else\n            callback.call(this, null, member);\n    }\n\n    /**\n     * Resolves a custom method of the given name and arguments and returns an equivalent MethodCallExpression instance.\n     * @param method\n     * @param args\n     * @param {Function} callback\n     * @returns {MethodCallExpression}\n     */\n    resolveMethod(method, args, callback) {\n        if (typeof callback !== 'function')\n            //sync process\n            return null;\n        else\n            callback.call(this);\n    }\n\n    ///**\n    // * Resolves an equivalent expressiob based on the given OData token\n    // * @param {Token} token\n    // */\n    //OpenDataParser.prototype.resolveVariable = function(token, callback) {\n    //    return null;\n    //};\n\n    /**\n     * Get a collection of tokens by parsing the curent expression\n     * @returns {Array}\n     */\n    toList() {\n        if (typeof this.source !== 'string')\n            return [];\n        this.current = 0;\n        this.offset = 0;\n        const result = [];\n        let token = null;\n        while ((token = this.getNext()) != null)\n        {\n            result.push(token);\n        }\n        return result;\n    }\n\n    /**\n     * @returns Token\n     */\n    getNext() {\n        let _current = this.current;\n        const _source = this.source;\n        let _offset = this.offset;\n\n        if (_offset >= _source.length)\n            return null;\n\n        while (_offset < _source.length && OpenDataParser.isWhitespace(_source.charAt(_offset)))\n        {\n            _offset++;\n        }\n        if (_offset >= _source.length)\n            return null;\n        _current = _offset;\n        this.current = _current;\n        const c = _source.charAt(_current);\n        switch (c)\n        {\n            case '-':\n                return this.parseSign();\n\n            case '\\'':\n                return this.parseString(0);\n\n            case '(':\n            case ')':\n            case ',':\n            case '/':\n                return this.parseSyntax();\n            default:\n                if (OpenDataParser.isDigit(c))\n                {\n                    return this.parseNumeric();\n                }\n                else if (OpenDataParser.isIdentifierStartChar(c))\n                {\n                    return this.parseIdentifier(false);\n                }\n                else\n                {\n                    throw new Error(sprintf.sprintf('Unexpecter character \"%s\" at offset %s.', c , _current));\n                }\n        }\n    }\n\n    /**\n     * @returns {Token}\n     */\n    parseSyntax() {\n        /**\n         * @type {Token}\n         */\n        let token = null;\n        switch (this.source.charAt(this.current))\n        {\n            case '(': token = SyntaxToken.ParenOpen; break;\n            case ')': token = SyntaxToken.ParenClose; break;\n            case '/': token = SyntaxToken.Slash; break;\n            case ',': token = SyntaxToken.Comma; break;\n            default : throw new Error('Unknown token');\n        }\n        this.offset = this.current + 1;\n\n        return token;\n    }\n\n    /**\n     * @returns {Token}\n     */\n    parseIdentifier(minus) {\n        let _current = this.current;\n        const _source = this.source;\n        let _offset = this.offset;\n\n        for (_current++; _current < _source.length; _current++)\n        {\n            const c = _source.charAt(_current);\n            if (OpenDataParser.isIdentifierChar(c)==false)\n                break;\n        }\n\n        const name = _source.substr(_offset, _current - _offset).trim();\n\n        const lastOffset = _offset;\n        _offset = _current;\n        switch (name)\n        {\n            case \"INF\":\n                this.current = _current;this.offset=_offset;\n                return LiteralToken.PositiveInfinity;\n\n            case \"-INF\":\n                this.current = _current;this.offset=_offset;\n                return LiteralToken.NegativeInfinity;\n\n            case \"Nan\":\n                this.current = _current;this.offset=_offset;\n                return LiteralToken.NaN;\n\n            case \"true\":\n                this.current = _current;this.offset=_offset;\n                return LiteralToken.True;\n\n            case \"false\":\n                this.current = _current;this.offset=_offset;\n                return LiteralToken.False;\n\n            case \"null\":\n                this.current = _current;this.offset=_offset;\n                return LiteralToken.Null;\n\n            case \"-\":\n                this.current = _current;this.offset=_offset;\n                return SyntaxToken.Negative;\n\n            default:\n                if (minus) {\n                    // Reset the offset.\n                    _offset = lastOffset + 1;\n                    this.current = _current;this.offset=_offset;\n                    return SyntaxToken.Negative;\n                }\n                this.current = _current;this.offset=_offset;\n                break;\n        }\n        if (_offset < _source.length && _source.charAt(_offset) == '\\'')\n        {\n            let stringType;\n            switch (name)\n            {\n                case \"X\": stringType = LiteralToken.StringType.Binary; break;\n                case \"binary\": stringType = LiteralToken.StringType.Binary; break;\n                case \"datetime\": stringType = LiteralToken.StringType.DateTime; break;\n                case \"guid\": stringType = LiteralToken.StringType.Guid; break;\n                case \"time\": stringType = LiteralToken.StringType.Time; break;\n                case \"datetimeoffset\": LiteralToken.StringType = StringType.DateTimeOffset; break;\n                default: stringType = LiteralToken.StringType.None; break;\n            }\n\n            if (stringType != LiteralToken.StringType.None && _source.charAt(_offset) == '\\'')\n            {\n                const content = this.parseString();\n                return this.parseSpecialString(content.value, stringType);\n            }\n        }\n        return new IdentifierToken(name);\n    }\n\n    /**\n     * Parses a guid string and returns an open data token.\n     * @returns Token\n     */\n    parseGuidString(value) {\n        if (typeof value !== 'string')\n            throw new Error(sprintf.sprintf('Invalid argument at %s.', this.offset));\n        if (value.match(OpenDataParser.GuidRegex)!=null)\n            throw new Error(sprintf.sprintf('Guid format is invalid at %s.', this.offset));\n        return new LiteralToken(value, LiteralType.Guid);\n    }\n\n    /**\n     * Parses a time string and returns an open data token.\n     * @returns Token\n     */\n    parseTimeString(value) {\n        if (typeof value === 'undefined' || value==null)\n            return null;\n        const match = value.match(OpenDataParser.DurationRegex);\n        if (match!=null)\n        {\n            const negative = (match[1] == \"-\");\n            const year = match[2].length > 0 ? parseInt(match[2]) : 0, month = match[3].length > 0 ? parseInt(match[3]) : 0, day = match[4].length > 0 ? parseInt(match[4]) : 0, hour = match[5].length > 0 ? parseInt(match[5]) : 0, minute = match[6].length > 0 ? parseInt(match[6]) : 0, second = match[7].length > 0 ? parseFloat(match[7]) : 0;\n            return new LiteralToken(new TimeSpan(!negative, year, month, day, hour, minute, second), LiteralType.Duration);\n        }\n        else\n        {\n            throw new Error(sprintf.sprintf('Duration format is invalid at %s.', this.offset))\n        }\n    }\n\n    /**\n     * Parses a date time offset string and returns an open data token\n     * @param value\n     * @returns {LiteralToken}\n     */\n    parseBinaryString(value) {\n        throw new Error('Not Implemented');\n    }\n\n    /**\n     * Parses a date time offset string and returns an open data token\n     * @param value\n     * @returns {LiteralToken}\n     */\n    parseDateTimeOffsetString(value) {\n        return this.parseDateTimeString(value);\n    }\n\n    /**\n     * Parses a date time string and returns an open data token\n     * @param value\n     * @returns {LiteralToken}\n     */\n    parseDateTimeString(value) {\n        if (typeof value === 'undefined' || value==null)\n            return null;\n        const match = value.match(OpenDataParser.DateTimeRegex);\n        if (match!=null)\n        {\n            const year = parseInt(match[1]),\n                month = parseInt(match[2]),\n                day = parseInt(match[3]),\n                hour = parseInt(match[4]),\n                minute = parseInt(match[5]),\n                second = match[6].length > 0 ? parseInt(match[6]) : 0,\n                nanoSecond = match[7].length > 0 ? parseInt(match[7]) : 0;\n            return new LiteralToken(new Date(year, month, day, hour, minute, second), LiteralType.DateTime);\n        }\n        else\n        {\n            throw new Error(sprintf.sprintf('Datetime format is invalid at %s.', this.offset))\n        }\n    }\n\n    /**\n     * @returns Token\n     */\n    parseSpecialString(value, stringType) {\n        switch (stringType)\n        {\n            case LiteralToken.StringType.Binary:\n                return this.parseBinaryString(value);\n\n            case LiteralToken.StringType.DateTime:\n                return this.parseDateTimeString(value);\n\n            case LiteralToken.StringType.DateTimeOffset:\n                return this.parseDateTimeOffsetString(value);\n\n            case LiteralToken.StringType.Guid:\n                return this.parseGuidString(value);\n\n            case LiteralToken.StringType.Time:\n                return this.parseTimeString(value);\n\n            default:\n                throw new Error('Argument stringType was out of range.');\n        }\n    }\n\n    /**\n     * @returns {Token}\n     */\n    parseString() {\n        let hadEnd = false;\n        let _current = this.current;\n        const _source = this.source;\n        const _offset = this.offset;\n        let sb = '';\n        for (_current++; _current < _source.length; _current++)\n        {\n            const c = this.source.charAt(_current);\n\n            if (c == '\\'')\n            {\n                if ((_current < _source.length - 1) && (_source.charAt(_current+1) == '\\'')) {\n                    _current++;\n                    sb += '\\'';\n                }\n                else\n                {\n                    hadEnd = true;\n                    break;\n                }\n            }\n            else\n            {\n                sb +=c;\n            }\n        }\n\n        if (!hadEnd)\n        {\n            throw new Error(sprintf.sprintf('Unterminated string starting at %s', _offset));\n        }\n        this.current = _current;\n        this.offset = _current + 1;\n        return new LiteralToken(sb, LiteralToken.LiteralType.String);\n    }\n\n    skipDigits(current) {\n        const _source = this.source, _offset = this.offset;\n        if (!OpenDataParser.isDigit(_source.charAt(current)))\n            return null;\n        current++;\n        while (current < _source.length && OpenDataParser.isDigit(_source.charAt(current))) {\n            current++;\n        }\n        return current;\n    }\n\n    /**\n     * @returns {Token}\n     */\n    parseNumeric() {\n        let _current = this.current;\n        const _source = this.source;\n        let _offset = this.offset;\n        let floating = false;\n        let c = null;\n\n        for (_current++; _current < _source.length; _current++)\n        {\n            c = _source.charAt(_current);\n            if (c == OpenDataParser.CHR_POINT)\n            {\n                if (floating)\n                    break;\n                floating = true;\n            }\n            else if (!OpenDataParser.isDigit(c))\n            {\n                break;\n            }\n        }\n        let haveExponent = false;\n        if (_current < _source.length)\n        {\n            c = _source.charAt(_current);\n            if (c == 'E' || c == 'e')\n            {\n                _current++;\n                if (_source.charAt(_current) == '-')\n                    _current++;\n                const exponentEnd = (_current == _source.length) ? null : this.skipDigits(_current);\n                if (exponentEnd==null)\n                    throw new Error(sprintf.sprintf('Expected digits after exponent at %s.', _offset));\n                _current = exponentEnd;\n                haveExponent = true;\n\n                if (_current < _source.length) {\n                    c = _source.charAt(_current);\n                    if (c == 'm' || c == 'M')\n                        throw new Error(sprintf.sprintf('Unexpected exponent for decimal literal at %s.', _offset));\n                    else if (c == 'l' || c == 'L')\n                        throw new Error(sprintf.sprintf('Unexpected exponent for long literal at %s.', _offset));\n                }\n            }\n        }\n\n        const text = _source.substr(_offset, _current - _offset);\n        let value = null;\n        let type = null;\n\n        if (_current < _source.length)\n        {\n            c = _source.charAt(_current);\n\n            switch (c)\n            {\n                case 'F':\n                case 'f':\n                    value = parseFloat(text);\n                    type = LiteralToken.LiteralType.Single;\n                    _current++;\n                    break;\n\n                case 'D':\n                case 'd':\n                    value = parseFloat(text);\n                    type = LiteralToken.LiteralType.Double;\n                    _current++;\n                    break;\n\n                case 'M':\n                case 'm':\n                    value = parseFloat(text);\n                    type = LiteralToken.LiteralType.Decimal;\n                    _current++;\n                    break;\n\n                case 'L':\n                case 'l':\n                    value = parseInt(text);\n                    type = LiteralToken.LiteralType.Long;\n                    _current++;\n                    break;\n\n                default:\n                    if (floating || haveExponent)\n                    {\n                        value = parseFloat(text);\n                        type = LiteralToken.LiteralType.Double;\n                    }\n                    else\n                    {\n                        value = parseInt(text);\n                        type = LiteralToken.LiteralType.Int;\n                    }\n                    break;\n            }\n        }\n        else\n        {\n            if (floating || haveExponent)\n            {\n                value = parseFloat(text);\n                type = LiteralToken.LiteralType.Double;\n            }\n            else\n            {\n                value = parseInt(text);\n                type = LiteralToken.LiteralType.Int;\n            }\n        }\n\n        _offset = _current;\n        this.offset = _offset;\n        this.current = _current;\n        return new LiteralToken(value, type);\n    }\n\n    /**\n     * @returns {Token}\n     */\n    parseSign() {\n        this.current++;\n        if (OpenDataParser.isDigit(this.source.charAt(this.current)))\n            return this.parseNumeric();\n        else\n            return this.parseIdentifier(true);\n    }\n\n    /**\n     * @param {String} c\n     * @returns {boolean}\n     */\n    static isChar(c) {\n        return (c.match(OpenDataParser.REGEXP_CHAR)!=null);\n    }\n\n    /**\n     * @param {String} c\n     * @returns {boolean}\n     */\n    static isDigit(c) {\n        return (c.match(OpenDataParser.REGEXP_DIGIT)!=null);\n    }\n\n    static isIdentifierStartChar(c) {\n        return (c == OpenDataParser.CHR_UNDERSCORE) || (c == OpenDataParser.CHR_DOLLARSIGN) || OpenDataParser.isChar(c);\n    }\n\n    /**\n      * @param {String} c\n     * @returns {boolean}\n     */\n    static isWhitespace(c) {\n        return (c == OpenDataParser.CHR_WHITESPACE);\n    }\n\n    static isIdentifierChar(c) {\n        return OpenDataParser.isIdentifierStartChar(c) || OpenDataParser.isDigit(c);\n    }\n}\n\nOpenDataParser.ArithmeticOperatorRegEx = /^(\\$add|\\$sub|\\$mul|\\$div|\\$mod)$/g;\nOpenDataParser.LogicalOperatorRegEx = /^(\\$or|\\$nor|\\$not|\\$and)$/g;\n\nOpenDataParser.DurationRegex = /^(-)?P(?:(\\\\d+)Y)?(?:(\\\\d+)M)?(?:(\\\\d+)D)?T?(?:(\\\\d+)H)?(?:(\\\\d+)M)?(?:(\\\\d+(?:\\\\.\\\\d*)?)S)?$/g;\nOpenDataParser.GuidRegex = /^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/g;\nOpenDataParser.DateTimeRegex = /^(\\\\d{4})-(\\\\d{1,2})-(\\\\d{1,2})T(\\\\d{1,22}):(\\\\d{2})(?::(\\\\d{2})(?:\\\\.(\\\\d{7}))?)?$/g;\n\nOpenDataParser.REGEXP_CHAR = /[a-zA-Z]/g;\nOpenDataParser.REGEXP_DIGIT = /[0-9]/g;\nOpenDataParser.CHR_WHITESPACE = ' ';\nOpenDataParser.CHR_UNDERSCORE = '_';\nOpenDataParser.CHR_DOLLARSIGN = '$';\nOpenDataParser.CHR_POINT = '.';\n\nclass TimeSpan {\n    toString() {\n\n    }\n}\n\n/**\n * @class Token\n * @abstract Toke\n * @param {String} tokenType\n * @constructor\n */\nexport class Token {\n    constructor(tokenType) {\n        this.type = tokenType;\n    }\n\n    isParenOpen() {\n        return (this.type=='Syntax') && (this.syntax=='(');\n    }\n\n    isParenClose() {\n        return (this.type=='Syntax') && (this.syntax==')');\n    }\n\n    isSlash() {\n        return (this.type=='Syntax') && (this.syntax=='/');\n    }\n\n    isComma() {\n        return (this.type=='Syntax') && (this.syntax==',');\n    }\n\n    isNegative() {\n        return (this.type=='Syntax') && (this.syntax=='-');\n    }\n}\n\nToken.TokenType = {\n    Literal : 'Literal',\n    Identifier: 'Identifier',\n    Syntax: 'Syntax'\n};\n\nToken.Operator ={\n    Not:'$not',\n    // Multiplicative\n    Mul:'$mul',\n    Div:'$div',\n    Mod:'$mod',\n    // Additive\n    Add:'$add',\n    Sub:'$sub',\n    // Relational and type testing\n    Lt:'$lt',\n    Gt:'$gt',\n    Le:'$lte',\n    Ge:'$gte',\n    // Equality\n    Eq:'$eq',\n    Ne:'$ne',\n    // In Values\n    In:'$in',\n    NotIn:'$nin',\n    // Conditional AND\n    And:'$and',\n    // Conditional OR\n    Or:'$or'\n};\n\n\n/**\n * @class LiteralToken\n * @param {*} value\n * @param {String} literalType\n * @constructor\n */\nexport class LiteralToken extends Token {\n    constructor(value, literalType) {\n        super(Token.TokenType.Literal);\n        this.value = value;\n        this.literalType = literalType;\n    }\n}\n\nLiteralToken.LiteralType = {\n    Null: 'Null',\n    String: 'String',\n    Boolean: 'Boolean',\n    Single: 'Single',\n    Double: 'Double',\n    Decimal: 'Decimal',\n    Int: 'Int',\n    Long: 'Long',\n    Binary: 'Binary',\n    DateTime: 'DateTime',\n    Guid: 'Guid',\n    Duration:'Duration'\n};\n\nLiteralToken.StringType =\n{\n    None:'None',\n    Binary:'Binary',\n    DateTime:'DateTime',\n    Guid:'Guid',\n    Time:'Time',\n    DateTimeOffset:'DateTimeOffset'\n};\n\nLiteralToken.PositiveInfinity = new LiteralToken(NaN, LiteralToken.LiteralType.Double);\nLiteralToken.NegativeInfinity = new LiteralToken(NaN, LiteralToken.LiteralType.Double);\nLiteralToken.NaN = new LiteralToken(NaN, LiteralToken.LiteralType.Double);\nLiteralToken.True = new LiteralToken(true, LiteralToken.LiteralType.Boolean);\nLiteralToken.False = new LiteralToken(false, LiteralToken.LiteralType.Boolean);\nLiteralToken.Null = new LiteralToken(null, LiteralToken.LiteralType.Null);\n\n\n/**\n * @class IdentifierToken\n * @param {String} The identifier's name\n * @constructor\n */\nexport class IdentifierToken extends Token {\n    constructor(name) {\n        super(Token.TokenType.Identifier);\n        this.identifier = name;\n    }\n\n    valueOf() {\n        return this.identifier;\n    }\n}\n\n/**\n * @class SyntaxToken\n * @param {String} chr\n * @constructor\n */\nexport class SyntaxToken extends Token {\n    constructor(chr) {\n        super(Token.TokenType.Syntax);\n        this.syntax = chr;\n    }\n\n    valueOf() {\n        return this.syntax;\n    }\n}\n\nSyntaxToken.ParenOpen = new SyntaxToken('(');\nSyntaxToken.ParenClose = new SyntaxToken(')');\nSyntaxToken.Slash = new SyntaxToken('/');\nSyntaxToken.Comma = new SyntaxToken(',');\nSyntaxToken.Negative = new SyntaxToken('-');"]}