{"version":3,"sources":["associations.es6"],"names":["async","ParserUtils","_","DataObjectAssociationListener","e","callback","isNil","target","keys","Object","mappings","forEach","x","hasOwnProperty","mapping","model","inferMapping","associationType","childModel","name","push","eachSeries","cb","field","childField","property","parentField","parseBoolean","cloned","associatedModel","context","parentModel","er","find","select","silent","flatten","take","list","err","result","Error","code","total","records","event","obj","convert","childs","junction","isArray","HasParentJunction","require","$silent","getBaseModel","state","toBeRemoved","toBeInserted","$state","insert","remove","DataObjectJunction","DataObjectTag","tags","all","then","filter","indexOf","length","catch"],"mappings":"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","file":"associations.js","sourcesContent":["/**\n * @license\n * MOST Web Framework 2.0 Codename Blueshift\n * Copyright (c) 2014, Kyriakos Barbounakis k.barbounakis@gmail.com\n *                     Anthi Oikonomou anthioikonomou@gmail.com\n *\n * Use of this source code is governed by an BSD-3-Clause license that can be\n * found in the LICENSE file at https://themost.io/license\n */\n\nimport async from 'async';\nimport {ParserUtils} from './types';\nimport {_} from 'lodash';\n\n/**\n * @class\n */\nexport class DataObjectAssociationListener {\n    /**\n     *\n     * @param {DataEventArgs} e\n     * @param {function(Error=)} callback\n     */\n    beforeSave(e, callback) {\n        try {\n            if (_.isNil(e.target)) {\n                return callback();\n            }\n            else {\n                const keys = Object.keys(e.target);\n                const mappings = [];\n                keys.forEach(function(x) {\n                    if (e.target.hasOwnProperty(x) && typeof e.target[x] === 'object' && e.target[x] != null) {\n                            //try to find field mapping, if any\n                            const mapping = e.model.inferMapping(x);\n                            if (mapping && mapping.associationType==='association' && mapping.childModel===e.model.name)\n                                mappings.push(mapping);\n                    }\n                });\n                async.eachSeries(mappings,\n                    /**\n                     * @param {DataAssociationMapping} mapping\n                     * @param {function(Error=)} cb\n                     */\n                    function(mapping, cb) {\n                        if (mapping.associationType==='association' && mapping.childModel===e.model.name) {\n                            /**\n                             * @type {DataField|*}\n                             */\n                            const field = e.model.field(mapping.childField), childField = field.property || field.name;\n                            //foreign key association\n                            if (typeof e.target[childField] !== 'object') {\n                                return cb();\n                            }\n                            if (e.target[childField].hasOwnProperty(mapping.parentField)) {\n                                return cb();\n                            }\n                            //change:21-Mar 2016\n                            //description: check if association belongs to this model or it's inherited from any base model\n                            //if current association belongs to base model\n                            if ((e.model.name !== field.model) && (!ParserUtils.parseBoolean(field.cloned))) {\n                                //do nothing and exit\n                                return cb();\n                            }\n\n                            //get associated mode\n                            const associatedModel = e.model.context.model(mapping.parentModel);\n\n                            let er;\n                            associatedModel.find(e.target[childField]).select(mapping.parentField).silent().flatten().take(1).list(function(err, result) {\n                                if (err) {\n                                    cb(err);\n                                }\n                                else if (_.isNil(result)) {\n                                    er = new Error('An associated object cannot be found.');er.code = 'EDATA';er.model = associatedModel.name;\n                                    cb(er);\n                                }\n                                else if (result.total==0) {\n                                    er = new Error('An associated object cannot be found.');er.code = 'EDATA';er.model = associatedModel.name;\n                                    cb(er);\n                                }\n                                else if (result.total>1) {\n                                    er = new Error('An associated object is defined more than once and cannot be bound.'); er.code = 'EDATA';er.model = associatedModel.name;\n                                    cb(er);\n                                }\n                                else {\n                                    e.target[childField][mapping.parentField]=result.records[0][mapping.parentField];\n                                    cb();\n                                }\n                            });\n                        }\n                        else {\n                           cb();\n                        }\n\n                    }, function(err) {\n                        callback(err);\n                    });\n            }\n        }\n        catch (e) {\n            callback(e);\n        }\n\n    }\n\n    /**\n     *\n     * @param {DataEventArgs} event\n     * @param {function(Error=)} callback\n     */\n    afterSave(event, callback) {\n        try {\n            if (typeof event.target === 'undefined' || event.target==null) {\n                callback(null);\n            }\n            else {\n                const keys = Object.keys(event.target);\n                const mappings = [];\n                keys.forEach(function(x) {\n                    if (event.target.hasOwnProperty(x)) {\n                        /**\n                         * @type DataAssociationMapping\n                         */\n                        const mapping = event.model.inferMapping(x);\n                        if (mapping)\n                            if (mapping.associationType=='junction') {\n                                mappings.push({ name:x, mapping:mapping });\n                            }\n                    }\n                });\n                async.eachSeries(mappings,\n                    /**\n                     * @param {{name:string,mapping:DataAssociationMapping}} x\n                     * @param {function(Error=)} cb\n                     */\n                    function(x, cb) {\n                        if (x.mapping.associationType=='junction') {\n                            const obj = event.model.convert(event.target);\n\n                            /**\n                             * @type {*|{deleted:Array}}\n                             */\n                            const childs = obj[x.name];\n\n                            let junction;\n                            if (!_.isArray(childs)) { return cb(); }\n                            if (x.mapping.childModel===event.model.name) {\n                                const HasParentJunction = require('./has-parent-junction').HasParentJunction;\n                                junction = new HasParentJunction(obj, x.mapping);\n                                if (event.model.$silent) {\n                                    junction.getBaseModel().silent();\n                                }\n                                if (event.state==1 || event.state==2) {\n                                    const toBeRemoved = [], toBeInserted = [];\n                                    _.forEach(childs, function(x) {\n                                        if (x.$state == 4) {\n                                            toBeRemoved.push(x);\n                                        }\n                                        else {\n                                            toBeInserted.push(x);\n                                        }\n                                    });\n                                    junction.insert(toBeInserted, function(err) {\n                                        if (err) { return cb(err); }\n                                        junction.remove(toBeRemoved, function(err) {\n                                            if (err) { return cb(err); }\n                                            return cb();\n                                        });\n                                    });\n                                }\n                                else  {\n                                    return cb();\n                                }\n                            }\n                            else if (x.mapping.parentModel===event.model.name) {\n\n                                if (event.state==1 || event.state==2) {\n                                    const DataObjectJunction = require('./data-object-junction').DataObjectJunction, DataObjectTag = require('./data-object-tag').DataObjectTag;\n\n                                    if (typeof x.mapping.childModel === 'undefined') {\n                                        /**\n                                         * @type {DataObjectTag}\n                                         */\n                                        const tags = new DataObjectTag(obj, x.mapping);\n                                        if (event.model.$silent) { tags.getBaseModel().silent(); }\n                                        return tags.silent().all().then(function(result) {\n                                            const toBeRemoved = result.filter(function(x) { return childs.indexOf(x)<0; });\n                                            const toBeInserted = childs.filter(function(x) { return result.indexOf(x)<0; });\n                                            if (toBeRemoved.length>0) {\n                                                return tags.remove(toBeRemoved).then(function() {\n                                                    if (toBeInserted.length==0) { return cb(); }\n                                                    return tags.insert(toBeInserted).then(function() {\n                                                        return cb();\n                                                    });\n                                                }).catch(function (err) {\n                                                    return cb(err);\n                                                });\n                                            }\n                                            if (toBeInserted.length==0) { return cb(); }\n                                            return tags.insert(toBeInserted).then(function() {\n                                                return cb();\n                                            });\n                                        }).catch(function (err) {\n                                            return cb(err);\n                                        });\n                                    }\n                                    else {\n                                        junction = new DataObjectJunction(obj, x.mapping);\n                                        if (event.model.$silent) { junction.getBaseModel().silent(); }\n                                        junction.insert(childs, function(err) {\n                                            if (err) { return cb(err); }\n                                            const toBeRemoved = [], toBeInserted = [];\n                                            _.forEach(childs, function(x) {\n                                                if (x.$state == 4) {\n                                                    toBeRemoved.push(x);\n                                                }\n                                                else {\n                                                    toBeInserted.push(x);\n                                                }\n                                            });\n                                            junction.insert(toBeInserted, function(err) {\n                                                if (err) { return cb(err); }\n                                                junction.remove(toBeRemoved, function(err) {\n                                                    if (err) { return cb(err); }\n                                                    return cb();\n                                                });\n                                            });\n                                        });\n                                    }\n                                }\n                                else  {\n                                    cb();\n                                }\n                            }\n                            else {\n                                cb();\n                            }\n                        }\n                        else\n                            cb(null);\n\n                    }, function(err) {\n                        callback(err);\n                    });\n            }\n        }\n        catch (err) {\n            callback(err);\n        }\n    }\n}"]}