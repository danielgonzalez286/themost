{"version":3,"sources":["listeners.es6"],"names":["ParserUtils","sprintf","async","moment","_","Q","TraceUtils","TextUtils","NotNullError","UniqueConstraintError","DataError","QueryField","QueryExpression","FunctionContext","NotNullConstraintListener","event","callback","attrs","model","attributes","filter","x","primary","nullable","length","eachSeries","attr","cb","name","property","value","target","undefined","state","er","process","env","NODE_ENV","log","err","UniqueConstraintListener","constraints","type","constraint","q","i","fields","mapping","inferMapping","parentField","and","equal","where","silent","select","primaryKey","first","result","objectExists","description","CalculatedValueListener","functionContext","assign","context","calculation","expr","indexOf","fnstr","substring","concat","eval","value1","call","then","catch","Error","evaluate","DataCachingListener","DataCache","require","isNil","caching","emitter","data","query","$select","hash","toMD5","key","logTime","Date","getTime","getCurrent","get","$expand","cached","debug","add","error","DefaultValueListener","DataModelCreateViewListener","self","db","view","viewAdapter","adapter","sourceAdapter","sealed","baseModel","base","map","many","create","from","baseAdapter","baseFields","isObject","forEach","push","to","$entity","$with","createView","DataModelSeedListener","items","isArray","asQueryable","flatten","count","$state","save","e","DataModelSubTypesListener","getSubTypes","ev","prototype","afterUpgrade","PreviousStateListener","DataStateValidatorListener","keyState","DataStateValidator_MapKey_","obj","arr","constraintCollection","objectFound","appendQueryFunc","hasOwnProperty","parentObj","parentModel","parentConstraint","find","DataNestedObjectListener","nested","DataNestedObject_BeforeSave_","DataNestedObject_BeforeRemove_","getPrimaryKey","nestedObj","nestedModel","nestedKey","DataNestedObject_BeforeSaveMany_","expand","originalNestedObjects","y","remove","id","DataNestedObject_BeforeRemoveMany_","junction","all","clear"],"mappings":"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","file":"listeners.js","sourcesContent":["/**\n * @license\n * MOST Web Framework 2.0 Codename Blueshift\n * Copyright (c) 2014, Kyriakos Barbounakis k.barbounakis@gmail.com\n *                     Anthi Oikonomou anthioikonomou@gmail.com\n *\n * Use of this source code is governed by an BSD-3-Clause license that can be\n * found in the LICENSE file at https://themost.io/license\n */\n'use strict';\nimport 'source-map-support/register';\nimport {ParserUtils} from './types';\nimport sprintf from 'sprintf';\nimport async from 'async';\nimport moment from 'moment';\nimport {_} from 'lodash';\nimport Q from 'q';\nimport {TraceUtils, TextUtils} from \"@themost/common/utils\";\nimport {NotNullError,UniqueConstraintError,DataError} from '@themost/common/errors';\nimport {QueryField, QueryExpression} from \"@themost/query/query\";\nimport {FunctionContext} from './functions';\n\n\n/**\n * @classdesc Represents an event listener for validating not nullable fields. This listener is automatically  registered in all data models.\n * @class\n */\nexport class NotNullConstraintListener {\n    /**\n     * Occurs before creating or updating a data object and validates not nullable fields.\n     * @param {DataEventArgs|*} event - An object that represents the event arguments passed to this operation.\n     * @param {Function} callback - A callback function that should be called at the end of this operation. The first argument may be an error if any occured.\n     */\n    beforeSave(event, callback) {\n\n        //find all attributes that have not null flag\n        const attrs = event.model.attributes.filter(\n            function(x) {\n                return !x.primary && !(typeof x.nullable === 'undefined' ? true: x.nullable);\n            });\n        if (attrs.length==0) {\n            callback(null);\n            return 0;\n        }\n        async.eachSeries(attrs, function(attr, cb)\n        {\n            const name = attr.property || attr.name, value = event.target[name];\n            if ((((value == null) || (value===undefined))  && (event.state==1))\n                || ((value == null) && (typeof value!=='undefined') && (event.state == 2)))\n            {\n                const er = new NotNullError('A value is required.', null, event.model.name, attr.name);\n                if (process.env.NODE_ENV==='development') { TraceUtils.log(er); }\n                return cb(er);\n            }\n            else\n                cb(null);\n        }, function(err) {\n            callback(err);\n        });\n    }\n}\n\n/**\n * @class\n * @classdesc Represents an event listener for validating data model's unique constraints. This listener is automatically registered in all data models.\n */\nexport class UniqueConstraintListener {\n    /**\n     * Occurs before creating or updating a data object and validates the unique constraints of data model.\n     * @param {DataEventArgs|*} event - An object that represents the event arguments passed to this operation.\n     * @param {Function} callback - A callback function that should be called at the end of this operation. The first argument may be an error if any occured.\n     */\n    beforeSave(event, callback) {\n\n        //there are no constraints\n        if (event.model.constraints==null)\n        {\n            //do nothing\n            callback(null);\n            return;\n        }\n        //get unique constraints\n        const constraints = _.filter(event.model.constraints, function(x) {\n            return (x.type=='unique');\n        });\n        if (constraints.length==0) {\n            //do nothing\n            callback(null);\n            return;\n        }\n        async.eachSeries(constraints, function(constraint, cb)\n        {\n            /**\n             * @type {DataQueryable}\n             */\n            let q;\n            //build query\n            for (let i = 0; i < constraint.fields.length; i++) {\n                const attr = constraint.fields[i];\n                let value = event.target[attr];\n                if (typeof value === 'undefined') {\n                    cb(null);\n                    return;\n                }\n                //check field mapping\n                const mapping = event.model.inferMapping(attr);\n                if (typeof mapping !== 'undefined' && mapping !== null) {\n                    if (typeof event.target[attr] === 'object') {\n                        value=event.target[attr][mapping.parentField];\n                    }\n                }\n                if (typeof value=== 'undefined')\n                    value = null;\n                if (q) {\n                    q.and(attr).equal(value);\n                }\n                else {\n                    q = event.model.where(attr).equal(value);\n                }\n            }\n            if (typeof q === 'undefined')\n                cb(null);\n            else {\n                q.silent().select(event.model.primaryKey).first(function(err, result) {\n                    if (err) {\n                        cb(err);\n                        return;\n                    }\n                    if (!result) {\n                        //object does not exist\n                        cb(null);\n                    }\n                    else {\n                        let objectExists = true;\n                        if (event.state==2) {\n                            //validate object id (check if target object is the same with the returned object)\n                            objectExists = (result[event.model.primaryKey]!= event.target[event.model.primaryKey]);\n                        }\n                        //if object already exists\n                        if (objectExists) {\n                            let er;\n                            //so throw exception\n                            if (constraint.description) {\n                                er = new UniqueConstraintError(constraint.description, null, event.model.name);\n                            }\n                            else {\n                                er = new UniqueConstraintError(\"Object already exists. A unique constraint violated.\", null, event.model.name);\n                            }\n                            if (process.env.NODE_ENV==='development') { TraceUtils.log(er); }\n                            return cb(er);\n                        }\n                        else {\n                            return cb();\n                        }\n                    }\n                });\n            }\n        }, function(err) {\n            callback(err);\n        });\n    }\n}\n\n/**\n * @class\n * @classdesc Represents an event listener which calculates field values. This listener is being registered for all data models.\n <p>\n A data field may have a calculation attribute.\n An instance of <a href=\"FunctionContext.html\">FunctionContext</a> class will calculate this value by evaluating the expression provided.\n <pre class=\"prettyprint\"><code>\n {\n        \"name\": \"modifiedBy\",\n        \"title\": \"Modified By\",\n        \"description\": \"Modified by user.\",\n        \"type\": \"User\",\n        \"calculation\":\"javascript:return this.user();\"\n    }\n </code></pre>\n <p>In the previous example modifiedBy field has a calculation for setting the user which performs the update operation.</p>\n<p><strong>Note:</strong>FunctionContext class may be extended in order to allow applications to perform value calculations.</p>\n <pre class=\"prettyprint\"><code>\n    FunctionContext.prototype.myColor = function() {\n        var deferred = Q.defer(),\n            self = this;\n        process.nextTick(function() {\n            return self.context.model(\"UserColor\")\n                .where(\"user/name\").equal(self.context.user.name)\n                .select(\"color\")\n                .value().then(function(value) {\n                    deferred.resolve(value);\n                }).catch(function(err) {\n                    deferred.reject(err);\n                });\n        });\n        return deferred.promise;\n    }\n </code></pre>\n <pre class=\"prettyprint\"><code>\n {\n        \"name\": \"color\",\n        \"title\": \"Color\",\n        \"type\": \"Text\",\n        \"calculation\":\"javascript:return this.myColor();\"\n    }\n </code></pre>\n <p>In this example a custom method of FunctionContext class gets the user's favourite color.</p>\n <p>This calculation may also be performed by setting the following promise expression:</p>\n <pre class=\"prettyprint\"><code>\n {\n        \"name\": \"color\",\n        \"title\": \"Color\",\n        \"type\": \"Text\",\n        \"calculation\":\"javascript:return this.context.model('UserColor').where('user/name').equal(this.context.user.name).select('color').value();\"\n    }\n </code></pre>\n </p>\n */\nexport class CalculatedValueListener {\n    /**\n     * Occurs before creating or updating a data object and calculates field values with the defined calculation expression.\n     * @param {DataEventArgs} event - An object that represents the event arguments passed to this operation.\n     * @param {Function} callback - A callback function that should be called at the end of this operation. The first argument may be an error if any occured.\n     */\n    beforeSave(event, callback) {\n        //get function context\n        const functionContext = new FunctionContext();\n        _.assign(functionContext, event);\n        functionContext.context = event.model.context;\n        //find all attributes that have a default value\n        const attrs = _.filter(event.model.attributes, function(x) {\n            return (typeof x.calculation!== 'undefined');\n        });\n        async.eachSeries(attrs, function(attr, cb) {\n            const expr = attr.calculation;\n            //validate expression\n            if (typeof expr !== 'string') {\n                event.target[attr.name] = expr;\n                return cb();\n            }\n            //check javascript: keyword for code evaluation\n            if (expr.indexOf('javascript:')==0) {\n                //get expression\n                let fnstr = expr.substring('javascript:'.length);\n                //if expression starts with function add parenthesis (fo evaluation)\n                if (fnstr.indexOf('function')==0) {\n                    fnstr = '('.concat(fnstr,')');\n                }\n                //if expression starts with return then normalize expression (surround with function() {} keyword)\n                else if (fnstr.indexOf('return')==0) {\n                    fnstr = '(function() { '.concat(fnstr,'})');\n                }\n                const value = eval(fnstr);\n                //if value is function\n                if (typeof value === 'function') {\n                    //then call function against the target object\n                    const value1 = value.call(functionContext);\n                    if (typeof value1 !== 'undefined' && value1 !=null && typeof value1.then === 'function') {\n                        //we have a promise, so we need to wait for answer\n                        value1.then(function(result) {\n                            //otherwise set result\n                            event.target[attr.name] = result;\n                            return cb();\n                        }).catch(function(err) {\n                            cb(err);\n                        });\n                    }\n                    else {\n                        event.target[attr.name] = value1;\n                        return cb();\n                    }\n                }\n                else if (typeof value !== 'undefined' && value !=null && typeof value.then === 'function') {\n                    //we have a promise, so we need to wait for answer\n                    value.then(function(result) {\n                        //otherwise set result\n                        event.target[attr.name] = result;\n                        return cb();\n                    }).catch(function(err) {\n                        cb(err);\n                    });\n                }\n                else {\n                    //otherwise get value\n                    event.target[attr.name] = value;\n                    return cb();\n                }\n            }\n            else if (expr.indexOf('fn:')==0) {\n               return cb(new Error ('fn: syntax is deprecated.'));\n            }\n            else {\n                functionContext.evaluate(expr, function(err, result) {\n                    if (err) {\n                        cb(err);\n                    }\n                    else {\n                        event.target[attr.name] = result;\n                        cb(null);\n                    }\n                });\n            }\n\n        }, function(err) {\n            callback(err);\n        });\n    }\n}\n\n/**\n * @classdesc Represents a data caching listener which is going to be used while executing queries against\n * data models where data caching is enabled. This listener is registered by default.\n <p>\n      Data caching may be disabled when <a href=\"DataModel.html\">DataModel</a>.caching property is set to 'none'. This is the default behaviour of a data model.\n </p>\n <pre class=\"prettyprint\"><code>\n {\n     \"name\": \"Order\", ... , \"caching\":\"none\"\n     ...\n }\n </code></pre>\n <p>\n Data caching may be used when <a href=\"DataModel.html\">DataModel</a>.caching property is set to 'always'.\n </p>\n <pre class=\"prettyprint\"><code>\n {\n     \"name\": \"OrderStatus\", ... , \"caching\":\"always\"\n     ...\n }\n </code></pre>\n <p>\n Data caching may be conditionally enabled when <a href=\"DataModel.html\">DataModel</a>.caching property is set to 'conditional'.\n </p>\n <pre class=\"prettyprint\"><code>\n {\n     \"name\": \"Product\", ... , \"caching\":\"conditional\"\n     ...\n }\n </code></pre>\n <p>\n In this case, data caching will be used when an instance of <a href=\"DataQueryable.html\">DataQueryable</a> class requests data with cache equal to true:\n </p>\n <pre class=\"prettyprint\"><code>\n    context.model('Product')\n            .where('category').is('Laptops')\n            .cache(true)\n            .orderBy('name')\n            .list().then(function(result) {\n                done(null, result);\n            }).catch(function(err) {\n                done(err);\n            });\n </code></pre>\n * @class\n */\nexport class DataCachingListener {\n    /**\n     * Occurs before executing an query expression, validates data caching configuration and gets cached data.\n     * @param {DataEventArgs|*} event - An object that represents the event arguments passed to this operation.\n     * @param {Function} callback - A callback function that should be called at the end of this operation. The first argument may be an error if any occured.\n     */\n    beforeExecute(event, callback) {\n        try {\n            const DataCache = require('./cache').DataCache;\n            if (_.isNil(event)) {\n                return callback();\n            }\n            //validate caching\n            const caching = (event.model.caching==='always' || event.model.caching==='conditional');\n            if (!caching) { return callback(); }\n            //validate conditional caching\n            if (event.model.caching==='conditional') {\n                if (event.emitter && typeof event.emitter.data === 'function') {\n                    if (!event.emitter.data('cache')) {\n                        return callback();\n                    }\n                }\n            }\n            if (event.query && event.query.$select) {\n                //create hash\n                let hash;\n                if (event.emitter && typeof event.emitter.toMD5 === 'function') {\n                    //get hash from emitter (DataQueryable)\n                    hash = event.emitter.toMD5();\n                }\n                else {\n                    //else calculate hash\n                    hash = TextUtils.toMD5({ query: event.query });\n                }\n                //format cache key\n                const key = '/' + event.model.name + '/?query=' + hash;\n                //calculate execution time (debug)\n                const logTime = new Date().getTime();\n                //query cache\n                return DataCache.getCurrent().get(key).then((result)=> {\n                    if (typeof result !== 'undefined') {\n                        //delete expandables\n                        if (event.emitter) {\n                            delete event.emitter.$expand;\n                        }\n                        //set cached flag\n                        event['cached'] = true;\n                        //set execution default\n                        event['result'] = result;\n                        //log execution time (debug)\n                        try {\n                            if (process.env.NODE_ENV==='development') {\n                                TraceUtils.log(sprintf.sprintf('Cache (Execution Time:%sms):%s', (new Date()).getTime()-logTime, key));\n                            }\n                        }\n                        catch(err) { }\n                        //exit\n                        return callback();\n                    }\n                    else {\n                        //do nothing and exit\n                        return callback();\n                    }\n                }).catch((err) => {\n                    TraceUtils.log('DataCacheListener: An error occured while trying to get cached data.');\n                    TraceUtils.log(err);\n                    return callback();\n                });\n            }\n            else {\n                return callback();\n            }\n        }\n        catch (err) {\n            return callback(err);\n        }\n    }\n\n    /**\n     * Occurs before executing an query expression, validates data caching configuration and stores data to cache.\n     * @param {DataEventArgs|*} e - An object that represents the event arguments passed to this operation.\n     * @param {Function} callback - A callback function that should be called at the end of this operation. The first argument may be an error if any occured.\n     */\n    afterExecute(event, callback) {\n        try {\n            const DataCache = require('./cache').DataCache;\n            //validate caching\n            const caching = (event.model.caching==='always' || event.model.caching==='conditional');\n            if (!caching) { return callback(); }\n            //validate conditional caching\n            if (event.model.caching==='conditional') {\n                if (event.emitter && typeof event.emitter.data === 'function') {\n                    if (!event.emitter.data('cache')) {\n                        return callback();\n                    }\n                }\n            }\n            if (event.query && event.query.$select) {\n                if (typeof event.result !== 'undefined' && !event.cached) {\n                    //create hash\n                    let hash;\n                    if (event.emitter && typeof event.emitter.toMD5 === 'function') {\n                        //get hash from emitter (DataQueryable)\n                        hash = event.emitter.toMD5();\n                    }\n                    else {\n                        //else calculate hash\n                        hash = TextUtils.toMD5({ query: event.query });\n                    }\n                    const key = '/' + event.model.name + '/?query=' + hash;\n                    if (process.env.NODE_ENV==='development') {\n                        TraceUtils.debug('DataCacheListener: Setting data to cache [' + key + ']');\n                    }\n                    return DataCache.getCurrent().add(key, event.result).then(() => {\n                        return callback();\n                    }).catch((err) => {\n                        TraceUtils.error('An error occurred while adding item in data cache');\n                        TraceUtils.error(err);\n                        return callback();\n                    });\n                }\n            }\n            return callback();\n        }\n        catch(err) {\n            return callback(err);\n        }\n    }\n}\n\n/**\n * @class\n * @classdesc Represents an event listener for calculating default values.\n * DefaultValueListener is one of the default listeners which are being registered for all data models.\n <p>\n A data field may have a default value attribute.\n An instance of <a href=\"FunctionContext.html\">FunctionContext</a> class will calculate this value by evaluating the expression provided.\n The default value listener will process all fields of an inserted data object which have a default value expression and does not have a defined value.\n <pre class=\"prettyprint\"><code>\n {\n        \"name\": \"createdBy\",\n        \"title\": \"Created By\",\n        \"type\": \"User\",\n        \"value\":\"javascript:return this.user();\",\n        \"readonly\":true\n    }\n </code></pre>\n <p></p>\n <p><strong>Note:</strong> FunctionContext class may be extended in order to allow applications to perform value calculations.</p>\n </p>\n */\nexport class DefaultValueListener {\n    /**\n     * Occurs before creating or updating a data object and calculates default values with the defined value expression.\n     * @param {DataEventArgs|*} event - An object that represents the event arguments passed to this operation.\n     * @param {Function} callback - A callback function that should be called at the end of this operation. The first argument may be an error if any occured.\n     */\n    beforeSave(event, callback) {\n\n        const state = event.state!==undefined ? event.state : 0;\n        if (state!=1)\n        {\n            callback(null);\n        }\n        else {\n            //get function context\n            const functionContext = new FunctionContext();\n            _.assign(functionContext, event);\n            //find all attributes that have a default value\n            const attrs = _.filter(event.model.attributes, function(x) {\n                return (typeof x.value!== 'undefined');\n            });\n            async.eachSeries(attrs, function(attr, cb) {\n                const expr = attr.value;\n                //if attribute is already defined\n                if (typeof event.target[attr.name] !== 'undefined') {\n                    //do nothing\n                    cb(null);\n                    return;\n                }\n                //validate expression\n                if (typeof expr !== 'string') {\n                    event.target[attr.name] = expr;\n                    return cb();\n                }\n                //check javascript: keyword for code evaluation\n                if (expr.indexOf('javascript:')==0) {\n                    //get expression\n                    let fnstr = expr.substring('javascript:'.length);\n                    //if expression starts with function add parenthesis (fo evaluation)\n                    if (fnstr.indexOf('function')==0) {\n                        fnstr = '('.concat(fnstr,')');\n                    }\n                    //if expression starts with return then normalize expression (surround with function() {} keyword)\n                    else if (fnstr.indexOf('return')==0) {\n                        fnstr = '(function() { '.concat(fnstr,'})');\n                    }\n                    const value = eval(fnstr);\n                    //if value is function\n                    if (typeof value === 'function') {\n                        //then call function against the target object\n                        const value1 = value.call(functionContext);\n                        if (typeof value1 !== 'undefined' && value1 !=null && typeof value1.then === 'function') {\n                            //we have a promise, so we need to wait for answer\n                            value1.then(function(result) {\n                                //otherwise set result\n                                event.target[attr.name] = result;\n                                return cb();\n                            }).catch(function(err) {\n                                cb(err);\n                            });\n                        }\n                        else {\n                            event.target[attr.name] = value1;\n                            return cb();\n                        }\n                    }\n                    else if (typeof value !== 'undefined' && value !=null && typeof value.then === 'function') {\n                        //we have a promise, so we need to wait for answer\n                        value.then(function(result) {\n                            //otherwise set result\n                            event.target[attr.name] = result;\n                            return cb();\n                        }).catch(function(err) {\n                           cb(err);\n                        });\n                    }\n                    else {\n                        //otherwise get value\n                        event.target[attr.name] = value;\n                        return cb();\n                    }\n                }\n                else if (expr.indexOf('fn:')==0) {\n                    return cb(new Error ('fn: syntax is deprecated.'));\n                }\n                else  {\n\n                    functionContext.evaluate(expr, function(err, result) {\n                        if (err) {\n                            cb(err);\n                        }\n                        else {\n                            event.target[attr.name] = result;\n                            cb(null);\n                        }\n                    });\n                }\n\n            }, function(err) {\n                callback(err);\n            });\n        }\n    }\n}\n\n/**\n * @class\n */\nexport class DataModelCreateViewListener {\n    /**\n     * Occurs after upgrading a data model.\n     * @param {DataEventArgs} event - An object that represents the event arguments passed to this operation.\n     * @param {Function} callback - A callback function that should be called at the end of this operation. The first argument may be an error if any occured.\n     */\n    afterUpgrade(event, callback) {\n\n        const self = event.model, db = self.context.db;\n        const view = self.viewAdapter, adapter = self.sourceAdapter;\n        //if data model is a sealed model do nothing anb exit\n        if (self.sealed) { return callback(); }\n        //if view adapter is the same with source adapter do nothing and exit\n        if (view===adapter) { return callback(); }\n        const baseModel = self.base();\n        //get array of fields\n        const fields = _.map(_.filter(self.attributes, function(x) {\n            return (self.name== x.model) && (!x.many);\n        }), function(x) {\n            return QueryField.create(x.name).from(adapter);\n        });\n        /**\n         * @type {QueryExpression}\n         */\n        const q = QueryExpression.create(adapter).select(fields);\n        //get base adapter\n        const baseAdapter = (baseModel!=null) ? baseModel.name.concat('Data') : null, baseFields = [];\n        //enumerate columns of base model (if any)\n        if (_.isObject(baseModel)) {\n            baseModel.attributes.forEach(function(x) {\n                //get all fields (except primary and one-to-many relations)\n                if ((!x.primary) && (!x.many))\n                    baseFields.push(QueryField.create(x.name).from(baseAdapter))\n            });\n        }\n        if (baseFields.length>0)\n        {\n            const from = QueryField.create(self.key().name).from(adapter),\n                to = QueryField.create(self.base().key().name).from(baseAdapter);\n            q.$expand = { $entity: { },$with:[] };\n            q.$expand.$entity[baseAdapter]=baseFields;\n            q.$expand.$with.push(from);\n            q.$expand.$with.push(to);\n        }\n        //execute query\n        return db.createView(view, q, function(err) {\n            callback(err);\n        });\n    }\n}\n\n/**\n * @class\n */\nexport class DataModelSeedListener {\n    /**\n     * Occurs after upgrading a data model.\n     * @param {DataEventArgs} event - An object that represents the event arguments passed to this operation.\n     * @param {Function} callback - A callback function that should be called at the end of this operation. The first argument may be an error if any occured.\n     */\n    afterUpgrade(event, callback) {\n        const self = event.model;\n        try {\n            /**\n             * Gets items to be seeded\n             * @type {Array}\n             */\n            const items = self['seed'];\n            //if model has an array of items to be seeded\n            if (_.isArray(items)) {\n                if (items.length==0) {\n                    //if seed array is empty exit\n                    return callback();\n                }\n                //try to insert items if model does not have any record\n                self.asQueryable().silent().flatten().count(function(err, count) {\n                    if (err) {\n                        callback(err); return;\n                    }\n                    //if model has no data\n                    if (count==0) {\n                        //set items state to new\n                        items.forEach(function(x) { x.$state=1; });\n                        self.silent().save(items, callback);\n                    }\n                    else {\n                        //model was already seeded\n                        return callback();\n                    }\n                });\n            }\n            else {\n                //do nothing and exit\n                return callback();\n            }\n        }\n        catch (e) {\n            callback(e);\n        }\n    }\n}\n\n/**\n * @class\n */\nexport class DataModelSubTypesListener {\n    /**\n     * Occurs after upgrading a data model.\n     * @param {DataEventArgs} event - An object that represents the event arguments passed to this operation.\n     * @param {Function} callback - A callback function that should be called at the end of this operation. The first argument may be an error if any occured.\n     */\n    afterUpgrade(event, callback) {\n        const self = event.model, context = event.model.context;\n        try {\n            self.getSubTypes().then(function(result) {\n                if (result.length==0) { return callback(); }\n                //enumerate sub types\n                async.eachSeries(result, function(name, cb) {\n                    //get model\n                    const model = context.model(name);\n                    if (_.isNil(model)) { return cb(); }\n                    //if model is sealed do nothing\n                    if (model.sealed) { return cb(); }\n                    //create event arguments\n                    const ev = { model:model };\n                    //execute create view listener\n                    DataModelCreateViewListener.prototype.afterUpgrade(ev, cb);\n                }, function(err) {\n                    return callback(err);\n                });\n            }).catch(function(err) {\n                return callback(err);\n            });\n        }\n        catch (e) {\n            callback(e);\n        }\n    }\n}\n\n/**\n * @class\n */\nexport class PreviousStateListener {\n    /**\n     * Occurs before creating or updating a data object and validates not nullable fields.\n     * @param {DataEventArgs|*} event - An object that represents the event arguments passed to this operation.\n     * @param {Function} callback - A callback function that should be called at the end of this operation. The first argument may be an error if any occured.\n     */\n    beforeSave(event, callback) {\n        if (event.state==1) { return callback(); }\n        const key = event.model.primaryKey;\n        if (_.isNil(event.target[key])) {\n            return callback();\n        }\n        event.model.where(key).equal(event.target[key]).silent().first(function(err,result) {\n            if (err) {\n                return callback(err);\n            }\n            else {\n                event['previous'] = result;\n                return callback();\n            }\n        });\n    }\n}\n\n/**\n * @class\n * @classdesc Validates the state of a data object. DataStateValidatorListener is one of the default listeners which are being registered for all data models.\n <p>If the target data object belongs to a model which has one or more constraints, it will try to validate object's state against these constraints.\n <p>In the following example the process tries to save the favourite color of a user and passes name instead of user's identifier.\n DataStateValidatorListener will try to find a user based on the unique constraint of User model and then\n it will try to validate object's state based on the defined unique constraint of UserColor model.</p>\n <pre class=\"prettyprint\"><code>\n // #User.json\n ...\n \"constraints\":[\n {\n     \"description\": \"User name must be unique across different records.\",\n     \"type\":\"unique\",\n     \"fields\": [ \"name\" ]\n }]\n ...\n </code></pre>\n <pre class=\"prettyprint\"><code>\n // #UserColor.json\n ...\n \"constraints\":[\n { \"type\":\"unique\", \"fields\": [ \"user\", \"tag\" ] }\n ]\n ...\n </code></pre>\n <pre class=\"prettyprint\"><code>\n var userColor = {\n        \"user\": {\n            \"name\":\"admin@example.com\"\n        },\n        \"color\":\"#FF3412\",\n        \"tag\":\"favourite\"\n    };\n context.model('UserColor').save(userColor).then(function(userColor) {\n        done();\n    }).catch(function (err) {\n        done(err);\n    });\n </code></pre>\n </p>\n */\nexport class DataStateValidatorListener {\n    /**\n     * Occurs before creating or updating a data object and validates object state.\n     * @param {DataEventArgs|*} event - An object that represents the event arguments passed to this operation.\n     * @param {Function} callback - A callback function that should be called at the end of this operation. The first argument may be an error if any occured.\n     */\n    beforeSave(event, callback) {\n        try {\n            if (_.isNil(event)) {\n                return callback();\n            }\n            if (_.isNil(event.state)) {event.state = 1; }\n\n            const model = event.model, target = event.target;\n            //if model or target is not defined do nothing and exit\n            if (_.isNil(model) || _.isNil(target)) {\n                return callback();\n            }\n            //get key state\n            const keyState = (model.primaryKey && target[model.primaryKey]);\n            //if target has $state property defined, set this state and exit\n            if (event.target.$state) {\n                event.state = event.target.$state;\n            }\n            //if object has primary key\n            else if (keyState) {\n                event.state = 2\n            }\n            //if state is Update (2)\n            if (event.state == 2) {\n                //if key exists exit\n                if (keyState)\n                    return callback();\n                else {\n                    return DataStateValidator_MapKey_(model, target, function(err) {\n                        if (err) { return callback(err); }\n                        //if object is mapped with a key exit\n                        return callback();\n                    });\n                }\n            }\n            else if (event.state == 1) {\n                if (!keyState) {\n                    return DataStateValidator_MapKey_(model, target, function(err, result) {\n                        if (err) { return callback(err); }\n                        if (result) {\n                            //set state to Update\n                            event.state = 2\n                        }\n                        return callback();\n                    });\n                }\n                //otherwise do nothing\n                return callback();\n            }\n            else {\n                return callback();\n            }\n\n        }\n        catch(er) {\n            callback(er);\n        }\n    }\n\n    /**\n     * Occurs before removing a data object and validates object state.\n     * @param {DataEventArgs|*} event - An object that represents the event arguments passed to this operation.\n     * @param {Function} callback - A callback function that should be called at the end of this operation. The first argument may be an error if any occured.\n     */\n    beforeRemove(event, callback) {\n        //validate event arguments\n        if (_.isNil(event)) { return callback(); }\n        //validate state (the default is Delete=4)\n        if (_.isNil(event.state)) {event.state = 4; }\n        const model = event.model, target = event.target;\n        //if model or target is not defined do nothing and exit\n        if (_.isNil(model) || _.isNil(target)) {\n            return callback();\n        }\n        //if object primary key is already defined\n        if (model.primaryKey && target[model.primaryKey]) {\n            event.state = 4;\n            //do nothing and exist\n            return callback();\n        }\n        DataStateValidator_MapKey_(model, target, function(err, result) {\n            if (err) {\n                return callback(err);\n            }\n            else if (result) {\n                //continue and exit\n                return callback();\n            }\n            else {\n                callback(new DataError('EFOUND', 'The target object cannot be found.',null, model.name));\n            }\n        });\n    }\n\n}\n\n/**\n * @memberOf DataStateValidatorListener\n * @param {*} model\n * @param {*} obj\n * @param {Function} callback\n * @private\n */\nfunction DataStateValidator_MapKey_(model, obj, callback) {\n    if (_.isNil(obj)) {\n        return callback(new Error('Object cannot be null at this context'));\n    }\n    if (model.primaryKey && obj[model.primaryKey]) {\n        //already mapped\n        return callback(null, true);\n    }\n\n    //get unique constraints\n    const arr = _.filter(model.constraintCollection, function(x) { return x.type==='unique' });\n\n    let objectFound=false;\n    if (arr.length==0) {\n        //do nothing and exit\n        return callback();\n    }\n    async.eachSeries(arr, function(constraint, cb) {\n        try {\n            if (objectFound) {\n                return cb();\n            }\n            /**\n             * @type {DataQueryable}\n             */\n            let q;\n            const appendQueryFunc = function(attr, value) {\n                if (_.isNil(value))\n                    value = null;\n                if (q)\n                    q.and(attr).equal(value);\n                else\n                    q = model.where(attr).equal(value);\n            };\n            if (_.isArray(constraint.fields)) {\n                for (let i = 0; i < constraint.fields.length; i++) {\n                    const attr = constraint.fields[i];\n                    if (!obj.hasOwnProperty(attr)) {\n                        return cb();\n                    }\n                    const parentObj = obj[attr], value = parentObj;\n                    //check field mapping\n                    const mapping = model.inferMapping(attr);\n                    if (_.isObject(mapping) && (typeof parentObj === 'object')) {\n                        if (parentObj.hasOwnProperty(mapping.parentField)) {\n                            appendQueryFunc(attr, parentObj[mapping.parentField]);\n                        }\n                        else {\n                            /**\n                             * Try to find if parent model has a unique constraint and constraint fields are defined\n                             * @type {DataModel}\n                             */\n                            const parentModel = model.context.model(mapping.parentModel), parentConstraint = parentModel.constraintCollection.find(function(x) { return x.type==='unique' });\n                            if (parentConstraint) {\n                                parentConstraint.fields.forEach(function(x) {\n                                    appendQueryFunc(attr + \"/\" + x, parentObj[x]);\n                                });\n                            }\n                            else {\n                                appendQueryFunc(attr, null);\n                            }\n                        }\n                    }\n                    else {\n                        appendQueryFunc(attr, value);\n                    }\n                }\n                if (_.isNil(q)) {\n                    cb();\n                }\n                else {\n                    q.silent().flatten().select(model.primaryKey).value(function(err, result) {\n                        if (err) {\n                            cb(err);\n                        }\n                        else if (result) {\n                            //set primary key value\n                            obj[model.primaryKey] = result;\n                            //object found\n                            objectFound=true;\n                            cb();\n                        }\n                        else {\n                            cb();\n                        }\n                    });\n                }\n            }\n            else {\n                cb();\n            }\n        }\n        catch(err) {\n            cb(err);\n        }\n    }, function(err) {\n        callback(err, objectFound);\n    });\n}\n\n\n/**\n * @class\n */\nexport class DataNestedObjectListener {\n    /**\n     * @param {DataEventArgs} event\n     * @param {Function} callback\n     */\n    beforeSave(event, callback) {\n        try {\n            //get attributes with nested property set to on\n            const nested = _.filter(event.model.attributes, function(x) {\n                //only if these attributes belong to current model\n                return x.nested && (x.model === event.model.name);\n            });\n            //if there are no attribute defined as nested do nothing\n            if (nested.length === 0) { return callback(); }\n            async.eachSeries(nested, function(attr, cb) {\n                return DataNestedObject_BeforeSave_(attr, event, cb);\n            }, function(err) {\n                return callback(err);\n            });\n        }\n        catch (e) {\n            return callback(e);\n        }\n    }\n\n    beforeRemove(event, callback) {\n        try {\n            //get attributes with nested property set to on\n            const nested = _.filter(event.model.attributes, function(x) {\n                //only if these attributes belong to current model\n                return x.nested && (x.model === event.model.name);\n            });\n            //if there are no attribute defined as nested, do nothing and exit\n            if (nested.length === 0) { return callback(); }\n            async.eachSeries(nested, function(attr, cb) {\n                return DataNestedObject_BeforeRemove_(attr, event, cb);\n            }, function(err) {\n                return callback(err);\n            });\n        }\n        catch (e) {\n            return callback(e);\n        }\n    }\n}\n\n/**\n * @memberOf DataNestedObjectListener\n * @param {DataField} attr\n * @param {DataEventArgs} event\n * @param {Function} callback\n * @private\n */\nfunction DataNestedObject_BeforeSave_(attr, event, callback) {\n    const context = event.model.context, name = attr.property || attr.name, key = event.model.getPrimaryKey(), nestedObj = event.target[name];\n    //if attribute is null or undefined do nothing\n    if (_.isNil(nestedObj)) {\n        return callback();\n    }\n    //get target model\n    const nestedModel = context.model(attr.type);\n    if (_.isNil(nestedModel)) {\n        return callback();\n    }\n    if (event.state==1) {\n        //save nested object\n        nestedModel.silent().save(nestedObj, function(err) {\n            callback(err);\n        });\n    }\n    else if (event.state == 2) {\n        //first of all get original address from db\n        event.model.where(key)\n            .equal(event.target[key])\n            .select(key,name)\n            .silent()\n            .first().then((result) => {\n            if (_.isNil(result)) { return callback(new Error('Invalid object state.')); }\n            const nestedKey = nestedModel.getPrimaryKey();\n            if (_.isNil(result[name])) {\n                //first of all delete nested object id (for insert)\n                delete nestedObj[nestedKey];\n                //save data\n                nestedModel.silent().save(nestedObj).then(function() {\n                    return callback();\n                }).catch(function(err) {\n                    return callback(err);\n                });\n            }\n            else {\n                //set nested object id (for update)\n                nestedObj[nestedKey] = result[name][nestedKey];\n                nestedModel.silent().save(nestedObj).then(function() {\n                    return callback();\n                }).catch(function(err) {\n                    return callback(err);\n                });\n            }\n        }).catch((err) => {\n            return callback(err);\n        });\n    }\n    else {\n        return callback();\n    }\n}\n/**\n * @memberOf DataNestedObjectListener\n * @param {DataField} attr\n * @param {DataEventArgs} event\n * @param {Function} callback\n * @private\n */\nfunction DataNestedObject_BeforeSaveMany_(attr, event, callback) {\n    const context = event.model.context, name = attr.property || attr.name, key = event.model.getPrimaryKey(), nestedObj = event.target[name];\n    //if attribute is null or undefined\n    if (_.isNil(nestedObj)) {\n        //do nothing\n        return callback();\n    }\n    //if nested object is not an array\n    if (!_.isArray(nestedObj)) {\n        //throw exception\n        return callback(new DataError(\"EJUNCT\",\"Invalid argument type. Expected array.\",null, event.model.name, name));\n    }\n    //if nested array does not have any data\n    if (nestedObj.length==0) {\n        //do nothing\n        return callback();\n    }\n    //get target model\n    const nestedModel = context.model(attr.type);\n    //if target model cannot be found\n    if (_.isNil(nestedModel)) {\n        return callback();\n    }\n    //get nested primary key\n    const nestedKey = nestedModel.getPrimaryKey();\n    //on insert\n    if (event.state==1) {\n        //enumerate nested objects and set state to new\n        nestedObj.forEach(function(x) {\n            //delete identifier\n            delete x[nestedKey];\n            //force state to new ($state=1)\n            x.$state = 1;\n        });\n        //save nested objects\n        nestedModel.silent().save(nestedObj, function(err) {\n            //remove $state attribute\n            nestedObj.forEach(function(x) { delete x.$state; });\n            //and return\n            callback(err);\n        });\n    }\n    //on update\n    else if (event.state == 2) {\n        //first of all get original associated object, if any\n        event.model.where(key)\n            .equal(event.target[key])\n            .select(key,name)\n            .expand(name)\n            .silent()\n            .first(function(err, result) {\n                if (err) { return callback(err); }\n                //if original object cannot be found, throw an invalid state exception\n                if (_.isNil(result)) { return callback(new Error('Invalid object state.')); }\n                //get original nested objects\n                const originalNestedObjects = result[name] || [];\n                //enumerate nested objects\n                nestedObj.forEach(function(x) {\n                    //search in original nested objects\n                    const obj = originalNestedObjects.find(function(y) { return y[nestedKey] == x[nestedKey]; });\n                    //if object already exists\n                    if (obj) {\n                        //force state to update ($state=2)\n                        x.$state = 2;\n                    }\n                    else {\n                        //delete identifier\n                        delete x[nestedKey];\n                        //force state to new ($state=1)\n                        x.$state = 1;\n                    }\n                });\n                //and finally save objects\n                nestedModel.silent().save(nestedObj, function(err) {\n                    //remove $state attribute\n                    nestedObj.forEach(function(x) { delete x.$state; });\n                    if (err) { return callback(err); }\n                    return callback();\n                });\n            });\n    }\n    else {\n        return callback();\n    }\n}\n\n/**\n * @memberOf DataNestedObjectListener\n * @param {DataField} attr\n * @param {DataEventArgs} event\n * @param {Function} callback\n * @private\n */\nfunction DataNestedObject_BeforeRemove_(attr, event, callback) {\n    try {\n        if (event.state !== 4) { return callback(); }\n        const context = event.model.context, name = attr.property || attr.name, key = event.model.getPrimaryKey();\n        const nestedModel = context.model(attr.type);\n        if (_.isNil(nestedModel)) { return callback(); }\n        event.model.where(key).equal(event.target[key]).select(key,name).flatten().silent().first(function(err, result) {\n            if (err) { return callback(err); }\n            if (_.isNil(result)) { return callback(); }\n            if (_.isNil(result[name])) { return callback(); }\n            nestedModel.remove({id:result[name]}, function(err) {\n                return callback(err);\n            });\n        });\n    }\n    catch (e) {\n        callback(e)\n    }\n}\n\n/**\n * @memberOf DataNestedObjectListener\n * @param {DataField} attr\n * @param {DataEventArgs} event\n * @param {Function} callback\n * @private\n */\nfunction DataNestedObject_BeforeRemoveMany_(attr, event, callback) {\n    try {\n        if (event.state !== 4) { return callback(); }\n        const context = event.model.context, name = attr.property || attr.name;\n        const nestedModel = context.model(attr.type);\n        if (_.isNil(nestedModel)) { return callback(); }\n        //get junction\n        const junction = event.target.property(name);\n        //select object identifiers (get all objects in silent mode to avoid orphaned objects)\n        junction.select(nestedModel.getPrimaryKey()).silent().all().then(function(result) {\n            //first of all remove all associations\n            junction.clear(function(err) {\n                if (err) { return callback(err); }\n                //and afterwards remove nested objects\n                nestedModel.silent().remove(result, function(err) {\n                    if (err) { return callback(); }\n                });\n            });\n        }).catch(function(err) {\n            return callback(err);\n        });\n    }\n    catch (e) {\n        callback(e)\n    }\n}"]}