{"version":3,"sources":["cache.es6"],"names":["_","Q","NodeCache","HttpApplicationService","AbstractClassError","AbstractMethodError","Args","TraceUtils","LangUtils","CacheStrategy","app","check","new","target","key","value","absoluteExpiration","fn","rawCacheProperty","Symbol","CACHE_ABSOLUTE_EXPIRATION","DefaultCacheStrategy","expiration","config","getConfiguration","settings","cache","parseInt","stdTTL","nfbind","set","bind","flushAll","self","isFunction","get","then","res","isNil","source","add"],"mappings":"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","file":"cache.js","sourcesContent":["/**\n * @license\n * MOST Web Framework 2.0 Codename Blueshift\n * Copyright (c) 2014, Kyriakos Barbounakis k.barbounakis@gmail.com\n *                     Anthi Oikonomou anthioikonomou@gmail.com\n *\n * Use of this source code is governed by an BSD-3-Clause license that can be\n * found in the LICENSE file at https://themost.io/license\n */\nimport 'source-map-support/register';\nimport {_} from 'lodash';\nimport Q from 'q';\nimport NodeCache from 'node-cache';\nimport {HttpApplicationService} from './interfaces';\nimport {AbstractClassError,AbstractMethodError} from '@themost/common/errors';\nimport {Args,TraceUtils,LangUtils} from '@themost/common/utils';\n\n/**\n * @classdesc Represents cache strategy for an HTTP application\n * @class\n * @abstract\n */\nexport class CacheStrategy extends HttpApplicationService {\n    /**\n     *\n     * @param {HttpApplication} app\n     */\n    constructor(app) {\n        Args.check(new.target !== CacheStrategy, new AbstractClassError());\n        super(app);\n    }\n    /**\n     * Sets a key value pair in cache.\n     * @abstract\n     * @param {string} key - A string that represents the key of the cached value\n     * @param {*} value - The value to be cached\n     * @param {number=} absoluteExpiration - An absolute expiration time in seconds. This parameter is optional.\n     * @returns {Promise}\n     */\n    add(key, value, absoluteExpiration) {\n        throw new AbstractMethodError();\n    }\n\n    /**\n     * Removes a cached value.\n     * @abstract\n     * @param {string} key - A string that represents the key of the cached value to be removed\n     * @returns {Promise}\n     */\n    remove(key) {\n        throw new AbstractMethodError();\n    }\n    /**\n     * Flush all cached data.\n     * @abstract\n     * @returns {Promise}\n     */\n    clear() {\n        throw new AbstractMethodError();\n    }\n    /**\n     * Gets a cached value defined by the given key.\n     * @param {string} key\n     * @returns {Promise}\n     */\n    get(key) {\n        throw new AbstractMethodError();\n    }\n    /**\n     * Gets data from cache or executes the defined function and adds the result to the cache with the specified key\n     * @param {string|*} key - A string which represents the key of the cached data\n     * @param {Function} fn - A function to execute if data will not be found in cache\n     * @param {number=} absoluteExpiration - An absolute expiration time in seconds. This parameter is optional.\n     * @returns {Promise}\n     */\n    getOrDefault(key, fn, absoluteExpiration) {\n        throw new AbstractMethodError();\n    }\n\n}\n\nconst rawCacheProperty = Symbol('rawCache');\nconst CACHE_ABSOLUTE_EXPIRATION = 0;\n\n/**\n * @classdesc Implements the cache for a data application.\n * @class\n */\nexport class DefaultCacheStrategy extends CacheStrategy  {\n    /**\n     *\n     * @constructor\n     * @param {HttpApplication} app\n     */\n    constructor(app) {\n        super(app);\n        //set absoluteExpiration (from application configuration)\n        let expiration = CACHE_ABSOLUTE_EXPIRATION;\n        const config = app.getConfiguration();\n        if (config.settings && config.cache && config.cache['absoluteExpiration']) {\n            if (LangUtils.parseInt(config.cache['absoluteExpiration'])>=0) {\n                expiration = LangUtils.parseInt(config.cache['absoluteExpiration']);\n            }\n        }\n        this[rawCacheProperty] = new NodeCache( {\n            stdTTL:expiration\n        });\n\n    }\n\n    /**\n     * Removes a cached value.\n     * @abstract\n     * @param {string} key - A string that represents the key of the cached value to be removed\n     * @returns {Promise}\n     */\n    remove(key) {\n        return Q.nfbind(this[rawCacheProperty].set.bind(this[rawCacheProperty]))(key);\n    }\n\n    /**\n    * Flush all cached data.\n     * @returns {Promise}\n    */\n    clear() {\n        this[rawCacheProperty].flushAll();\n        return Q();\n    }\n\n    /**\n     * Sets a key value pair in cache.\n     * @param {string} key - A string that represents the key of the cached value\n     * @param {*} value - The value to be cached\n     * @param {number=} absoluteExpiration - An absolute expiration time in seconds. This parameter is optional.\n     * @returns {Promise}\n     */\n    add(key, value, absoluteExpiration) {\n\n        return Q.nfbind(this[rawCacheProperty].set, this[rawCacheProperty])(key, value, absoluteExpiration);\n\n    }\n\n    /**\n     * Gets data from cache or executes the defined function and adds the result to the cache with the specified key\n     * @param {string|*} key - A string which represents the key of the cached data\n     * @param {Function} fn - A function to execute if data will not be found in cache\n     * @param {number=} absoluteExpiration - An absolute expiration time in seconds. This parameter is optional.\n     * @returns {Promise}\n     */\n    getOrDefault(key, fn, absoluteExpiration) {\n        const self = this;\n        Args.check(_.isFunction(fn),'Invalid argument. Expected function.');\n        return self.get(key).then((res) => {\n            if (_.isNil(res)) {\n                let source = fn();\n                Args.check(typeof source.then !== 'function', 'Invalid argument. Expected a valid observable.');\n                return source.then((res) => {\n                    if (_.isNil(res)) {\n                        return Q();\n                    }\n                    return self.add(key,res,absoluteExpiration);\n                });\n            }\n            return Q(res);\n        });\n    }\n\n    /**\n     * Gets a cached value defined by the given key.\n     * @param {string|*} key\n     * @returns {Promise}\n     */\n    get(key) {\n        return Q.nfbind(this[rawCacheProperty].get.bind(this[rawCacheProperty]))(key)\n            .then((res) => {\n                return Q(res[key]);\n            });\n\n    }\n}"]}