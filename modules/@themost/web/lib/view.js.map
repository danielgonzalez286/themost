{"version":3,"sources":["view.es6"],"names":["HttpError","HttpNotFoundError","TraceUtils","LangUtils","HttpNextResult","HttpEndResult","HttpConsumer","_","url","util","fs","path","xml","Rx","dasherize","s","isString","trim","replace","toLowerCase","STR_CONTROLLERS_FOLDER","STR_CONTROLLER_FILE","STR_CONTROLLER_RELPATH","ViewHandler","context","callback","self","request","currentHandler","requestUri","parse","currentRoute","route","isNil","controllerName","routeData","queryController","queryControllerClass","err","ControllerClass","controller","name","prototype","preflightRequest","call","obj","is","format","body","doc","loadXML","deserialize","documentElement","params","data","JSON","e","log","Error","allowCredentials","allowOrigin","allowHeaders","allowMethods","allow","headerNames","response","headers","origin","setHeader","indexOf","action","actionMethod","httpMethodDecorator","camelCase","method","controllerPrototype","Object","getPrototypeOf","protoActionMethods","filter","getOwnPropertyNames","x","httpAction","length","isValidControllerAction","queryControllerAction","methodParams","getFunctionParams","k","attr","push","apply","subscribe","result","controllerPath","getApplication","mapExecutionPath","controllerModel","model","exists","controllerType","type","join","__dirname","require","ControllerCtor","getConfiguration","controllers","default","undefined","segments","pathname","split","ViewConsumer","handler","Observable","bindNodeCallback","mapRequest","flatMap","postMapRequest","of","processRequest","res","toObservable"],"mappings":"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","file":"view.js","sourcesContent":["/**\n * @license\n * MOST Web Framework 2.0 Codename Blueshift\n * Copyright (c) 2014, Kyriakos Barbounakis k.barbounakis@gmail.com\n *                     Anthi Oikonomou anthioikonomou@gmail.com\n *\n * Use of this source code is governed by an BSD-3-Clause license that can be\n * found in the LICENSE file at https://themost.io/license\n */\n'use strict';\nimport {HttpError,HttpNotFoundError} from '@themost/common/errors';\nimport {TraceUtils, LangUtils} from '@themost/common/utils';\nimport {HttpNextResult, HttpEndResult} from './results';\nimport {HttpConsumer} from './consumers';\nimport {_} from 'lodash';\nimport url from 'url';\nimport util from 'util';\nimport fs from 'fs';\nimport path from 'path';\nimport xml from 'most-xml';\nimport Rx from 'rxjs';\n\n\nif (typeof _.dasherize != 'function') {\n    /**\n     * @param {string} s\n     * @returns string\n     */\n    _.dasherize = function (s) {\n        if (_.isString(s))\n            return _.trim(s).replace(/[_\\s]+/g, '-').replace(/([A-Z])/g, '-$1').replace(/-+/g, '-').replace(/^-/,'').toLowerCase();\n        return s;\n    }\n}\n\nconst STR_CONTROLLERS_FOLDER = 'controllers';\nconst STR_CONTROLLER_FILE = './controllers/%s.js';\nconst STR_CONTROLLER_RELPATH = 'controllers/%s-controller.js';\n\n/**\n * @classdesc Default view handler (as it had been implemented for version 1.x of MOST Web Framework)\n * @class\n */\nclass ViewHandler {\n    /**\n     *\n     * @param {string} controllerName\n     * @param {HttpContext} context\n     * @param {Function} callback\n     */\n    static queryControllerClass(controllerName, context, callback) {\n\n        if (typeof controllerName === 'undefined' || controllerName==null) {\n            callback();\n        }\n        else {\n            //get controller class path and model (if any)\n            let controllerPath = context.getApplication().mapExecutionPath(util.format(STR_CONTROLLER_RELPATH, _.dasherize(controllerName)));\n            const controllerModel = context.model(controllerName);\n            //if controller does not exists\n            fs.exists(controllerPath, function(exists){\n                try {\n                    //if controller class file does not exist in /controllers/ folder\n                    if (!exists) {\n                        //try to find if current controller has a model defined\n                        if (controllerModel) {\n                            const controllerType = controllerModel.type || 'data';\n                            //try to find controller based on the model's type in controllers folder (e.g. /library-controller.js)\n                            controllerPath = context.getApplication().mapExecutionPath(util.format(STR_CONTROLLER_RELPATH, controllerType));\n                            fs.exists(controllerPath, function(exists) {\n                               if (!exists) {\n                                   //get controller path according to related model's type (e.g ./data-controller)\n                                   controllerPath = util.format(STR_CONTROLLER_FILE, controllerType);\n                                   //if controller does not exist\n                                   controllerPath = path.join(__dirname, controllerPath);\n                                   fs.exists(controllerPath, function(exists) {\n                                       if (!exists)\n                                           callback(null, require('./controllers/base'));\n                                       else\n                                           callback(null, require(controllerPath));\n                                   });\n                               }\n                               else {\n                                   callback(null, require(controllerPath));\n                               }\n                            });\n                        }\n                        else {\n                            const ControllerCtor = context.getApplication().getConfiguration().controllers[controllerName] || require('./controllers/base').default;\n                            callback(null, ControllerCtor);\n                        }\n                    }\n                    else {\n                        //return controller class\n                        callback(null, require(controllerPath));\n                    }\n                }\n                catch (err) {\n                    callback(err);\n                }\n            });\n        }\n    }\n\n    /**\n     * @param {HttpContext} context\n     * @param {Function} callback\n     */\n    mapRequest(context, callback) {\n        const self = this;\n        callback = callback || function () { };\n        //try to map request\n        try {\n            //first of all check if a request handler is already defined\n            if (typeof context.request.currentHandler !== 'undefined') {\n                //do nothing (exit mapping)\n                return callback();\n            }\n            const requestUri = url.parse(context.request.url);\n            /**\n             * find route by querying application routes\n             * @type {HttpRoute}\n             */\n            const currentRoute = context.request.route;\n            if (_.isNil(currentRoute)) {\n                return callback();\n            }\n            //query controller\n            const controllerName = currentRoute[\"controller\"] || currentRoute.routeData[\"controller\"] || queryController(requestUri);\n            if (typeof controllerName === 'undefined' || controllerName == null) {\n                return callback();\n            }\n            //try to find controller class\n            ViewHandler.queryControllerClass(controllerName, context, function(err, ControllerClass) {\n                if (err) {\n                    return callback(err);\n                }\n                try {\n                    //initialize controller\n                    const controller = new ControllerClass();\n                    //set controller's name\n                    controller.name = controllerName.toLowerCase();\n                    //set controller's context\n                    controller.context = context;\n                    //set request handler\n                    self.controller = controller;\n                    context.request.currentHandler = self;\n                    return callback(null, true);\n                }\n                catch(err) {\n                    return callback(err);\n                }\n            });\n\n        }\n        catch (err) {\n            callback(err);\n        }\n\n    }\n\n    /**\n     * @param {HttpContext} context\n     * @param {Function} callback\n     */\n    postMapRequest(context, callback) {\n        try {\n            ViewHandler.prototype.preflightRequest.call(this, context, function(err) {\n                if (err) { return callback(err); }\n                let obj;\n                if (context.is('POST')) {\n                    if (context.format=='xml') {\n                        //get current model\n                        if (context.request.body) {\n                            //load xml\n                            try {\n                                const doc = xml.loadXML(context.request.body);\n                                obj = xml.deserialize(doc.documentElement);\n                                context.params.data = obj;\n                            }\n                            catch (err) {\n                                return callback(err);\n                            }\n                        }\n                    }\n                    else if (context.format=='json') {\n                        if (typeof context.request.body === 'string') {\n                            //parse json data\n                            try {\n                                obj = JSON.parse(context.request.body);\n                                //set context data\n                                context.params.data = obj;\n                            }\n                            catch(e) {\n                                //otherwise raise error\n                                TraceUtils.log(e);\n                                return callback(new Error('Invalid JSON data.'));\n                            }\n                        }\n                    }\n                }\n                return callback();\n            });\n        }\n        catch(err) {\n            callback(err);\n        }\n    }\n\n    /**\n     * @param {HttpContext} context\n     * @param {Function} callback\n     */\n    preflightRequest(context, callback) {\n        try {\n            if (context && (context.request.currentHandler instanceof ViewHandler)) {\n                //set the default origin (with wildcard)\n                let allowCredentials = true, allowOrigin=\"*\", allowHeaders = \"Origin, X-Requested-With, Content-Type, Content-Language, Accept, Accept-Language, Authorization\", allowMethods = \"GET, OPTIONS, PUT, POST, DELETE\";\n                /**\n                 * @private\n                 * @type {{allowOrigin:string,allowHeaders:string,allowCredentials:Boolean,allowMethods:string,allow:string}|*}\n                 */\n                const route = context.request.route;\n                if (route) {\n                    if (typeof route.allowOrigin !== 'undefined')\n                        allowOrigin = route.allowOrigin;\n                    if (typeof route.allowHeaders !== 'undefined')\n                        allowHeaders = route.allowHeaders;\n                    if (typeof route.allowCredentials !== 'undefined')\n                        allowCredentials = route.allowCredentials;\n                    if ((typeof route.allowMethods !== 'undefined') || (typeof route.allow !== 'undefined'))\n                        allowMethods = route.allow || route.allowMethods;\n                }\n                //ensure header names\n                const headerNames = context.response[\"_headerNames\"] || { };\n                //1. Access-Control-Allow-Origin\n                if (typeof headerNames[\"access-control-allow-origin\"] === 'undefined') {\n                    //if request contains origin header\n                    if (context.request.headers.origin) {\n                        if (allowOrigin === \"*\") {\n                            //set access-control-allow-origin header equal to request origin header\n                            context.response.setHeader(\"Access-Control-Allow-Origin\", context.request.headers.origin);\n                        }\n                        else if (allowOrigin.indexOf(context.request.headers.origin)>-1) {\n                            context.response.setHeader(\"Access-Control-Allow-Origin\", context.request.headers.origin);\n                        }\n                    }\n                    else {\n                        //set access-control-allow-origin header equal to the predefined origin header\n                        context.response.setHeader(\"Access-Control-Allow-Origin\", \"*\");\n                    }\n                }\n                //2. Access-Control-Allow-Origin\n                if (typeof headerNames[\"access-control-allow-credentials\"] === 'undefined') {\n                    context.response.setHeader(\"Access-Control-Allow-Credentials\", allowCredentials);\n                }\n\n                //3. Access-Control-Allow-Headers\n                if (typeof headerNames[\"access-control-allow-headers\"] === 'undefined') {\n                    context.response.setHeader(\"Access-Control-Allow-Headers\", allowHeaders);\n                }\n\n                //4. Access-Control-Allow-Methods\n                if (typeof headerNames[\"access-control-allow-methods\"] === 'undefined') {\n                    context.response.setHeader(\"Access-Control-Allow-Methods\", allowMethods);\n                }\n            }\n            if (typeof callback === 'undefined') { return; }\n            return callback();\n        }\n        catch(e) {\n            if (typeof callback === 'undefined') { throw e; }\n            callback(e);\n        }\n\n    }\n\n    /**\n     * @param {HttpContext} context\n     * @param {*} controller\n     * @param {string} action\n     * @returns {boolean}\n     */\n    static isValidControllerAction(context, controller, action) {\n        const httpMethodDecorator = _.camelCase('http-' + context.request.method);\n        if (typeof controller[action] === 'function') {\n            //get httpAction decorator\n            if ((typeof controller[action].httpAction === 'undefined') ||\n                (controller[action].httpAction===action)) {\n                //and supports current request method (see http decorators)\n                if (controller[action][httpMethodDecorator]) {\n                    //return this action\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     *\n     * @param {HttpContext} context\n     * @param {*} controller\n     * @param {string} action\n     * @returns {*}\n     */\n    queryControllerAction(context, controller, action) {\n        let actionMethod;\n        //get current http decorator name (e.g. httpGet, httpPost etc)\n        const httpMethodDecorator = _.camelCase('http-' + context.request.method);\n        //get camel cased action name (e.g. test-action as testAction)\n        const method = _.camelCase(action);\n        //get controller prototype\n        const controllerPrototype = Object.getPrototypeOf(controller);\n        if (controllerPrototype) {\n            //query controller methods that support current http request\n            let protoActionMethods = _.filter(Object.getOwnPropertyNames(controllerPrototype), function(x) {\n                return (typeof controller[x] === 'function')\n                    && (controller[x].httpAction === action)\n                    && (controller[x][httpMethodDecorator] === true);\n            });\n            //if an action was found for the given criteria\n            if (protoActionMethods.length==1) {\n                return controller[protoActionMethods[0]];\n            }\n        }\n        //if an action with the given name is a method of current controller\n        if (ViewHandler.isValidControllerAction(context, controller, action)) {\n            return controller[action];\n        }\n        //if an camel cased action with the given name is a method of current controller\n        if (ViewHandler.isValidControllerAction(context, controller, method)) {\n            return controller[method];\n        }\n    }\n\n    /**\n     * @param {HttpContext} context\n     * @param {Function} callback\n     */\n    processRequest(context, callback) {\n        const self = this;\n        callback = callback || function () { };\n        try {\n            if (context.is('OPTIONS')) {\n                //do nothing\n                return callback();\n            }\n            //validate request controller\n            const controller = self.controller;\n            if (controller) {\n                /**\n                 * try to find action\n                 * @type {String}\n                 */\n                const action = context.request.routeData[\"action\"];\n                if (action) {\n                    //query controller action\n                    let actionMethod = self.queryControllerAction(context, controller, action);\n                    if (typeof actionMethod !== 'function') {\n                        return callback(new HttpNotFoundError());\n                    }\n                    //enumerate params\n                    const methodParams = LangUtils.getFunctionParams(actionMethod), params = [];\n                    /*\n                    * enumerate method parameters and check if a parameter with the same name\n                    * exists in request's parameters.\n                    * */\n                    if (methodParams.length>0) {\n                        let k=0;\n                        while (k<methodParams.length) {\n                            //get context parameter\n                            if (typeof context.params.attr === 'function')\n                                params.push(context.params.attr(methodParams[k]));\n                            else\n                                params.push(context.params[methodParams[k]]);\n                            k++;\n                        }\n                    }\n                    return actionMethod.apply(controller, params).subscribe((result) => {\n                        return callback(null, result);\n                    },(err) => {\n                        return callback(err);\n                    });\n                }\n            }\n            return callback();\n        }\n        catch (err) {\n            return callback(err);\n        }\n    }\n\n}\n\n\n\n\n/**\n * Gets the controller of the given url\n * @param {string|*} requestUri - A string that represents the url we want to parse.\n * @private\n * */\nfunction queryController(requestUri) {\n    try {\n        if (requestUri === undefined)\n            return null;\n        //split path\n        const segments = requestUri.pathname.split('/');\n        //put an exception for root controller\n        //maybe this is unnecessary exception but we need to search for root controller e.g. /index.html, /about.html\n        if (segments.length == 2)\n            return 'root';\n        else\n        //e.g /pages/about where segments are ['','pages','about']\n        //and the controller of course is always the second segment.\n            return segments[1];\n\n    }\n    catch (err) {\n        throw err;\n    }\n}\n\n\nexport class ViewConsumer extends HttpConsumer {\n    constructor() {\n        super(function() {\n            /**\n             * @type {HttpContext}\n             */\n            const context = this;\n            try {\n                let handler = new ViewHandler();\n                //execute mapRequest\n                return Rx.Observable.bindNodeCallback(handler.mapRequest, handler)(context)\n                    .flatMap(()=> {\n                        //if request has been mapped\n                        if (context.request.currentHandler instanceof ViewHandler) {\n                            //execute post map request\n                            return Rx.Observable.bindNodeCallback(handler.postMapRequest, handler)(context);\n                        }\n                        //otherwise return next result\n                        return Rx.Observable.of(new HttpNextResult());\n                    }).flatMap(()=> {\n                        //if current handler is an instance of ViewHandler\n                        if (context.request.currentHandler instanceof ViewHandler) {\n                            //process request\n                            return Rx.Observable.bindNodeCallback(handler.processRequest, handler)(context).flatMap((res)=> {\n                                if (res instanceof HttpEndResult) {\n                                    return res.toObservable();\n                                }\n                                return Rx.Observable.of(res);\n                            });\n                        }\n                        return Rx.Observable.of(new HttpNextResult());\n                    });\n            }\n            catch(err) {\n                return Rx.Observable['throw'](err);\n            }\n        });\n    }\n}\n\n\n"]}