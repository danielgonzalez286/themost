{"version":3,"sources":["view.es6"],"names":["HttpError","HttpNotFoundError","TraceUtils","LangUtils","HttpNextResult","HttpEndResult","HttpConsumer","_","url","util","fs","path","xml","Rx","dasherize","s","isString","trim","replace","toLowerCase","STR_CONTROLLERS_FOLDER","STR_CONTROLLER_FILE","STR_CONTROLLER_RELPATH","ViewHandler","context","callback","self","request","currentHandler","requestUri","parse","currentRoute","route","isNil","controllerName","routeData","queryController","queryControllerClass","err","ControllerClass","controller","name","prototype","preflightRequest","call","obj","is","format","body","doc","loadXML","deserialize","documentElement","params","data","JSON","e","log","Error","allowCredentials","allowOrigin","allowHeaders","allowMethods","allow","headerNames","response","headers","origin","setHeader","indexOf","action","fn","camelCase","methodParams","getFunctionParams","length","k","push","attr","result","execute","create","apply","controllerPath","getApplication","mapExecutionPath","controllerModel","model","exists","controllerType","type","join","__dirname","require","ControllerCtor","getConfiguration","controllers","default","undefined","segments","pathname","split","ViewConsumer","handler","Observable","fromNodeCallback","mapRequest","flatMap","postMapRequest","return","processRequest","res","toObservable","throw"],"mappings":"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","file":"view.js","sourcesContent":["/**\n * @license\n * MOST Web Framework 2.0 Codename Blueshift\n * Copyright (c) 2014, Kyriakos Barbounakis k.barbounakis@gmail.com\n *                     Anthi Oikonomou anthioikonomou@gmail.com\n *\n * Use of this source code is governed by an BSD-3-Clause license that can be\n * found in the LICENSE file at https://themost.io/license\n */\n'use strict';\nimport {HttpError,HttpNotFoundError} from '@themost/common/errors';\nimport {TraceUtils, LangUtils} from '@themost/common/utils';\nimport {HttpNextResult, HttpEndResult} from './results';\nimport {HttpConsumer} from './consumers';\nimport {_} from 'lodash';\nimport url from 'url';\nimport util from 'util';\nimport fs from 'fs';\nimport path from 'path';\nimport xml from 'most-xml';\nimport Rx from 'rx';\n\n\nif (typeof _.dasherize != 'function') {\n    /**\n     * @param {string} s\n     * @returns string\n     */\n    _.dasherize = function (s) {\n        if (_.isString(s))\n            return _.trim(s).replace(/[_\\s]+/g, '-').replace(/([A-Z])/g, '-$1').replace(/-+/g, '-').replace(/^-/,'').toLowerCase();\n        return s;\n    }\n}\n\nconst STR_CONTROLLERS_FOLDER = 'controllers';\nconst STR_CONTROLLER_FILE = 'controllers/%s-controller.js';\nconst STR_CONTROLLER_RELPATH = 'controllers/%s-controller.js';\n\n/**\n * @classdesc Default view handler (as it had been implemented for version 1.x of MOST Web Framework)\n * @class\n */\nclass ViewHandler {\n    /**\n     *\n     * @param {string} controllerName\n     * @param {HttpContext} context\n     * @param {Function} callback\n     */\n    static queryControllerClass(controllerName, context, callback) {\n\n        if (typeof controllerName === 'undefined' || controllerName==null) {\n            callback();\n        }\n        else {\n            //get controller class path and model (if any)\n            let controllerPath = context.getApplication().mapExecutionPath(util.format(STR_CONTROLLER_RELPATH, _.dasherize(controllerName)));\n            const controllerModel = context.model(controllerName);\n            //if controller does not exists\n            fs.exists(controllerPath, function(exists){\n                try {\n                    //if controller class file does not exist in /controllers/ folder\n                    if (!exists) {\n                        //try to find if current controller has a model defined\n                        if (controllerModel) {\n                            const controllerType = controllerModel.type || 'data';\n                            //try to find controller based on the model's type in controllers folder (e.g. /library-controller.js)\n                            controllerPath = context.getApplication().mapExecutionPath(util.format(STR_CONTROLLER_RELPATH, controllerType));\n                            fs.exists(controllerPath, function(exists) {\n                               if (!exists) {\n                                   //get controller path according to related model's type (e.g ./data-controller)\n                                   controllerPath = util.format(STR_CONTROLLER_FILE, controllerType);\n                                   //if controller does not exist\n                                   controllerPath = path.join(__dirname, controllerPath);\n                                   fs.exists(controllerPath, function(exists) {\n                                       if (!exists)\n                                           callback(null, require('./../controllers/base'));\n                                       else\n                                           callback(null, require(controllerPath));\n                                   });\n                               }\n                               else {\n                                   callback(null, require(controllerPath));\n                               }\n                            });\n                        }\n                        else {\n                            const ControllerCtor = context.getApplication().getConfiguration().controllers[controllerName] || require('./../controllers/base').default;\n                            callback(null, ControllerCtor);\n                        }\n                    }\n                    else {\n                        //return controller class\n                        callback(null, require(controllerPath));\n                    }\n                }\n                catch (err) {\n                    callback(err);\n                }\n            });\n        }\n    }\n\n    /**\n     * @param {HttpContext} context\n     * @param {Function} callback\n     */\n    mapRequest(context, callback) {\n        const self = this;\n        callback = callback || function () { };\n        //try to map request\n        try {\n            //first of all check if a request handler is already defined\n            if (typeof context.request.currentHandler !== 'undefined') {\n                //do nothing (exit mapping)\n                return callback();\n            }\n            const requestUri = url.parse(context.request.url);\n            /**\n             * find route by querying application routes\n             * @type {HttpRoute}\n             */\n            const currentRoute = context.request.route;\n            if (_.isNil(currentRoute)) {\n                return callback();\n            }\n            //query controller\n            const controllerName = currentRoute[\"controller\"] || currentRoute.routeData[\"controller\"] || queryController(requestUri);\n            if (typeof controllerName === 'undefined' || controllerName == null) {\n                return callback();\n            }\n            //try to find controller class\n            ViewHandler.queryControllerClass(controllerName, context, function(err, ControllerClass) {\n                if (err) {\n                    return callback(err);\n                }\n                try {\n                    //initialize controller\n                    const controller = new ControllerClass();\n                    //set controller's name\n                    controller.name = controllerName.toLowerCase();\n                    //set controller's context\n                    controller.context = context;\n                    //set request handler\n                    self.controller = controller;\n                    context.request.currentHandler = self;\n                    return callback(null, true);\n                }\n                catch(err) {\n                    return callback(err);\n                }\n            });\n\n        }\n        catch (err) {\n            callback(err);\n        }\n\n    }\n\n    /**\n     * @param {HttpContext} context\n     * @param {Function} callback\n     */\n    postMapRequest(context, callback) {\n        try {\n            ViewHandler.prototype.preflightRequest.call(this, context, function(err) {\n                if (err) { return callback(err); }\n                let obj;\n                if (context.is('POST')) {\n                    if (context.format=='xml') {\n                        //get current model\n                        if (context.request.body) {\n                            //load xml\n                            try {\n                                const doc = xml.loadXML(context.request.body);\n                                obj = xml.deserialize(doc.documentElement);\n                                context.params.data = obj;\n                            }\n                            catch (err) {\n                                return callback(err);\n                            }\n                        }\n                    }\n                    else if (context.format=='json') {\n                        if (typeof context.request.body === 'string') {\n                            //parse json data\n                            try {\n                                obj = JSON.parse(context.request.body);\n                                //set context data\n                                context.params.data = obj;\n                            }\n                            catch(e) {\n                                //otherwise raise error\n                                TraceUtils.log(e);\n                                return callback(new Error('Invalid JSON data.'));\n                            }\n                        }\n                    }\n                }\n                return callback();\n            });\n        }\n        catch(err) {\n            callback(err);\n        }\n    }\n\n    /**\n     * @param {HttpContext} context\n     * @param {Function} callback\n     */\n    preflightRequest(context, callback) {\n        try {\n            if (context && (context.request.currentHandler instanceof ViewHandler)) {\n                //set the default origin (with wildcard)\n                let allowCredentials = true, allowOrigin=\"*\", allowHeaders = \"Origin, X-Requested-With, Content-Type, Content-Language, Accept, Accept-Language, Authorization\", allowMethods = \"GET, OPTIONS, PUT, POST, DELETE\";\n                /**\n                 * @private\n                 * @type {{allowOrigin:string,allowHeaders:string,allowCredentials:Boolean,allowMethods:string,allow:string}|*}\n                 */\n                const route = context.request.route;\n                if (route) {\n                    if (typeof route.allowOrigin !== 'undefined')\n                        allowOrigin = route.allowOrigin;\n                    if (typeof route.allowHeaders !== 'undefined')\n                        allowHeaders = route.allowHeaders;\n                    if (typeof route.allowCredentials !== 'undefined')\n                        allowCredentials = route.allowCredentials;\n                    if ((typeof route.allowMethods !== 'undefined') || (typeof route.allow !== 'undefined'))\n                        allowMethods = route.allow || route.allowMethods;\n                }\n                //ensure header names\n                const headerNames = context.response[\"_headerNames\"] || { };\n                //1. Access-Control-Allow-Origin\n                if (typeof headerNames[\"access-control-allow-origin\"] === 'undefined') {\n                    //if request contains origin header\n                    if (context.request.headers.origin) {\n                        if (allowOrigin === \"*\") {\n                            //set access-control-allow-origin header equal to request origin header\n                            context.response.setHeader(\"Access-Control-Allow-Origin\", context.request.headers.origin);\n                        }\n                        else if (allowOrigin.indexOf(context.request.headers.origin)>-1) {\n                            context.response.setHeader(\"Access-Control-Allow-Origin\", context.request.headers.origin);\n                        }\n                    }\n                    else {\n                        //set access-control-allow-origin header equal to the predefined origin header\n                        context.response.setHeader(\"Access-Control-Allow-Origin\", \"*\");\n                    }\n                }\n                //2. Access-Control-Allow-Origin\n                if (typeof headerNames[\"access-control-allow-credentials\"] === 'undefined') {\n                    context.response.setHeader(\"Access-Control-Allow-Credentials\", allowCredentials);\n                }\n\n                //3. Access-Control-Allow-Headers\n                if (typeof headerNames[\"access-control-allow-headers\"] === 'undefined') {\n                    context.response.setHeader(\"Access-Control-Allow-Headers\", allowHeaders);\n                }\n\n                //4. Access-Control-Allow-Methods\n                if (typeof headerNames[\"access-control-allow-methods\"] === 'undefined') {\n                    context.response.setHeader(\"Access-Control-Allow-Methods\", allowMethods);\n                }\n            }\n            if (typeof callback === 'undefined') { return; }\n            return callback();\n        }\n        catch(e) {\n            if (typeof callback === 'undefined') { throw e; }\n            callback(e);\n        }\n\n    }\n\n    /**\n     * @param {HttpContext} context\n     * @param {Function} callback\n     */\n    processRequest(context, callback) {\n        const self = this;\n        callback = callback || function () { };\n        try {\n            if (context.is('OPTIONS')) {\n                //do nothing\n                return callback();\n            }\n            //validate request controller\n            const controller = self.controller;\n            if (controller) {\n                /**\n                 * try to find action\n                 * @type {String}\n                 */\n                const action = context.request.routeData[\"action\"];\n                if (action) {\n                    //execute action\n                    let fn = controller[action];\n                    if (typeof fn !== 'function') {\n                        fn = controller[_.camelCase(action)];\n                        if (typeof fn !== 'function')\n                            fn = controller.action;\n                    }\n                    if (typeof fn !== 'function') {\n                        return callback(new HttpNotFoundError());\n                    }\n                    //enumerate params\n                    const methodParams = LangUtils.getFunctionParams(fn), params = [];\n                    /*\n                    * so if method has more than one parameter\n                    * enumerate method parameters and check if a parameter with the same name\n                    * exists in request's parameters.\n                    * note: the last parameter (in this version) must be a callback function\n                    * */\n                    if (methodParams.length>1) {\n                        let k=0;\n                        while (k<methodParams.length-1) {\n                            //get context parameter\n                            params.push(context.params.attr(methodParams[k]));\n                            k++;\n                        }\n                    }\n                    //and finally push callback function parameter\n                    /**\n                     * @type HttpResult\n                     * */\n                    params.push(function (err, result) {\n                        if (err) {\n                            //throw error\n                            return callback(err);\n                        }\n                        else {\n                            //execute http result\n                            result.execute(context, function(err) {\n                                if (err) {\n                                    return callback(err);\n                                }\n                                return callback(null, HttpEndResult.create());\n                            });\n                        }\n                    });\n                    //invoke controller method\n                    return fn.apply(controller, params);\n                }\n            }\n            return callback();\n        }\n        catch (err) {\n            return callback(err);\n        }\n    }\n\n}\n\n\n\n\n/**\n * Gets the controller of the given url\n * @param {string|*} requestUri - A string that represents the url we want to parse.\n * @private\n * */\nfunction queryController(requestUri) {\n    try {\n        if (requestUri === undefined)\n            return null;\n        //split path\n        const segments = requestUri.pathname.split('/');\n        //put an exception for root controller\n        //maybe this is unnecessary exception but we need to search for root controller e.g. /index.html, /about.html\n        if (segments.length == 2)\n            return 'root';\n        else\n        //e.g /pages/about where segments are ['','pages','about']\n        //and the controller of course is always the second segment.\n            return segments[1];\n\n    }\n    catch (err) {\n        throw err;\n    }\n}\n\n\nexport class ViewConsumer extends HttpConsumer {\n    constructor() {\n        super(function() {\n            /**\n             * @type {HttpContext}\n             */\n            const context = this;\n            try {\n                let handler = new ViewHandler();\n                //execute mapRequest\n                return Rx.Observable.fromNodeCallback(handler.mapRequest, handler)(context)\n                    .flatMap(()=> {\n                        //if request has been mapped\n                        if (context.request.currentHandler instanceof ViewHandler) {\n                            //execute post map request\n                            return Rx.Observable.fromNodeCallback(handler.postMapRequest, handler)(context);\n                        }\n                        //otherwise return next result\n                        return Rx.Observable.return(new HttpNextResult());\n                    }).flatMap(()=> {\n                        //if current handler is an instance of ViewHandler\n                        if (context.request.currentHandler instanceof ViewHandler) {\n                            //process request\n                            return Rx.Observable.fromNodeCallback(handler.processRequest, handler)(context).flatMap((res)=> {\n                                if (res instanceof HttpEndResult) {\n                                    return res.toObservable();\n                                }\n                                return Rx.Observable.return(new HttpNextResult());\n                            });\n                        }\n                        return Rx.Observable.return(new HttpNextResult());\n                    });\n            }\n            catch(err) {\n                return Rx.Observable.throw(err);\n            }\n        });\n    }\n}\n\n\n"]}