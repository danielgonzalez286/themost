{"version":3,"sources":["static.es6"],"names":["HttpServerError","HttpNotFoundError","HttpForbiddenError","TraceUtils","_","fs","url","path","crypto","HttpConsumer","Rx","HttpNextResult","HttpEndResult","StaticHandler","rootDir","whenDir","context","callback","uri","parse","request","pathname","isString","re","RegExp","escapeRegExp","test","replace","filePath","join","exists","stat","err","stats","isFile","currentHandler","currentExecutionPath","currentExecutionFileStats","executionPath","requestETag","headers","md5","createHash","update","mtime","toString","responseETag","digest","e","log","is","isNil","response","writeHead","end","extensionName","extname","mimes","getApplication","getConfiguration","contentType","contentEncoding","mime","filter","x","extension","type","encoding","source","createReadStream","pipe","on","StaticContentConsumer","handler","Observable","fromNodeCallback","mapRequest","flatMap","res","processRequest","create","toObservable","throw","MapStaticContentConsumer"],"mappings":"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","file":"static.js","sourcesContent":["/**\n * @license\n * MOST Web Framework 2.0 Codename Blueshift\n * Copyright (c) 2014, Kyriakos Barbounakis k.barbounakis@gmail.com\n *                     Anthi Oikonomou anthioikonomou@gmail.com\n *\n * Use of this source code is governed by an BSD-3-Clause license that can be\n * found in the LICENSE file at https://themost.io/license\n */\n'use strict';\nimport {HttpServerError,HttpNotFoundError,HttpForbiddenError} from '@themost/common/errors';\nimport {TraceUtils} from '@themost/common/utils';\nimport {_} from 'lodash';\nimport fs from 'fs';\nimport url from 'url';\nimport path from 'path';\nimport crypto from 'crypto';\nimport {HttpConsumer} from './consumers';\nimport Rx from 'rx';\nimport {HttpNextResult, HttpEndResult} from './results';\n\n/**\n * @classdesc Default static content handler (as it has been implemented for version 1.x of MOST Web Framework)\n * @class\n * @private\n */\nclass StaticHandler {\n\n    /**\n     *\n     * @param {string=} rootDir\n     */\n    constructor(rootDir) {\n        this.rootDir = rootDir || './app';\n        this.whenDir =  '/';\n    }\n\n    /**\n     *\n     * @param {HttpContext} context\n     * @param {Function} callback\n     */\n    mapRequest(context, callback) {\n        callback = callback || function() {};\n        try {\n            let uri = url.parse(context.request.url).pathname;\n            if (_.isString(this.whenDir) && this.whenDir!='/') {\n                const re = new RegExp('^' + _.escapeRegExp(this.whenDir),'ig');\n                if (!re.test(uri)) {\n                    return callback(null, false);\n                }\n                else {\n                    uri = uri.replace(re,'');\n                }\n            }\n            const filePath = path.join(this.rootDir, uri);\n            fs.exists(filePath, function(exists) {\n                if (!exists) {\n                    return callback(null, false);\n                }\n                else {\n                    fs.stat(filePath, function(err, stats) {\n                        if (err) {\n                            return callback(err);\n                        }\n                        //if file exists\n                        if (stats && stats.isFile()) {\n                            //set request current handler\n                            context.request.currentHandler = new StaticHandler();\n                            //set current execution path\n                            context.request.currentExecutionPath = filePath;\n                            //set file stats\n                            context.request.currentExecutionFileStats = stats;\n                            //return true\n                            return callback(null, true);\n                        }\n                        return callback(null, false);\n                    });\n                }\n            });\n        } catch (err) {\n            return callback(err);\n        }\n    }\n\n    unmodifiedRequest(context, executionPath, callback) {\n        try {\n            const requestETag = context.request.headers['if-none-match'];\n            if (typeof requestETag === 'undefined' || requestETag == null) {\n                callback(null, false);\n                return;\n            }\n            fs.exists(executionPath, function(exists) {\n                try {\n                    if (exists) {\n                        fs.stat(executionPath, function(err, stats) {\n                            if (err) {\n                                callback(err);\n                            }\n                            else {\n                                if (!stats.isFile()) {\n                                    callback(null, false);\n                                }\n                                else {\n                                    //validate if-none-match\n                                    const md5 = crypto.createHash('md5');\n                                    md5.update(stats.mtime.toString());\n                                    const responseETag = md5.digest('base64');\n                                    return callback(null, (requestETag==responseETag));\n                                }\n                            }\n                        });\n                    }\n                    else {\n                        callback(null, false);\n                    }\n                }\n                catch (e) {\n                    TraceUtils.log(e);\n                    callback(null, false);\n                }\n            });\n        }\n        catch (e) {\n            TraceUtils.log(e);\n            callback(null, false);\n        }\n    }\n\n    /**\n     * @param {HttpContext} context\n     * @param {Function} callback\n     */\n    processRequest(context, callback) {\n        callback = callback || function() {};\n        try {\n            if (context.is('OPTIONS')) {\n                //do nothing\n                return callback();\n            }\n            //get current execution path and validate once again file presence and MIME type\n            const stats = context.request.currentExecutionFileStats;\n            if (_.isNil(stats)) {\n                return callback(new HttpServerError('Invalid request handler.'));\n            }\n            if (!stats.isFile()) {\n                return callback(new HttpNotFoundError());\n            }\n            else {\n                //get if-none-match header\n                const requestETag = context.request.headers['if-none-match'];\n                //generate responseETag\n                const md5 = crypto.createHash('md5');\n                md5.update(stats.mtime.toString());\n                const responseETag = md5.digest('base64');\n                if (requestETag)\n                    if (requestETag==responseETag) {\n                        //context.response.writeHead(304, { 'Last-Modified':stats.mtime.toUTCString() });\n                        context.response.writeHead(304, { });\n                        context.response.end();\n                        return callback();\n                    }\n                //get file extension\n                const extensionName  = path.extname(context.request.currentExecutionPath);\n                //get MIME collection\n                const mimes = context.getApplication().getConfiguration().mimes;\n                let contentType = null, contentEncoding=null;\n                //find MIME type by extension\n                const mime =mimes.filter(function(x) { return x.extension==extensionName; })[0];\n                if (mime) {\n                    contentType = mime.type;\n                    if (mime.encoding)\n                        contentEncoding = mime.encoding;\n                }\n                //throw exception (MIME not found or access denied)\n                if (contentType==null) {\n                    return callback(new HttpForbiddenError())\n                }\n                else {\n                    //create stream\n                    const source = fs.createReadStream(context.request.currentExecutionPath);\n                    //write headers\n                    context.response.writeHead(200, {'Content-Type': contentType + (contentEncoding ? ';charset=' + contentEncoding : ''), 'ETag' : responseETag});\n                    //response file\n                    source.pipe(context.response);\n                    //handle end\n                    source.on('end', function() {\n                        callback();\n                    });\n                    //handle error\n                    source.on('error', function(err) {\n                        callback(err);\n                    });\n                }\n            }\n        }\n        catch (err) {\n            return callback(err);\n        }\n    }\n}\n\n\nexport class StaticContentConsumer extends HttpConsumer {\n    /**\n     * @param {string=} rootDir\n     * @constructor\n     */\n    constructor(rootDir) {\n        super(function() {\n            /**\n             * @type {HttpContext}\n             */\n            const context = this;\n            try {\n                let handler = new StaticHandler(rootDir);\n                return Rx.Observable.fromNodeCallback(handler.mapRequest,handler)(context)\n                    .flatMap((res) => {\n                        if (res) {\n                            return Rx.Observable.fromNodeCallback(handler.processRequest,handler)(context);\n                        }\n                        return HttpNextResult.create().toObservable();\n                    });\n            }\n            catch(err) {\n                return Rx.Observable.throw(err);\n            }\n        });\n    }\n}\n\nexport class MapStaticContentConsumer extends HttpConsumer {\n    /**\n     * @param {string=} whenDir\n     * @param {string=} rootDir\n     * @constructor\n     */\n    constructor(whenDir, rootDir) {\n        super(function() {\n            /**\n             * @type {HttpContext}\n             */\n            const context = this;\n            try {\n                let handler = new StaticHandler(rootDir);\n                handler.whenDir = whenDir;\n                return Rx.Observable.fromNodeCallback(handler.mapRequest,handler)(context)\n                    .flatMap((res) => {\n                        if (res) {\n                            return Rx.Observable.fromNodeCallback(handler.processRequest,handler)(context);\n                        }\n                        return HttpNextResult.create().toObservable();\n                    });\n            }\n            catch(err) {\n                return Rx.Observable.throw(err);\n            }\n        });\n    }\n}\n\n\n"]}