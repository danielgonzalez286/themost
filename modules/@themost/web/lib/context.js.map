{"version":3,"sources":["context.es6"],"names":["_","url","path","HttpViewContext","Args","TraceUtils","HttpBadRequestError","LocalizationStrategy","parseCookies","request","list","headers","cookie","rc","isEmpty","forEach","split","parts","shift","trim","unescape","join","cultureProperty","Symbol","applicationProperty","HttpContext","app","response","uri","parse","result","extname","pathname","substr","toLowerCase","mime","self","extension","name","notNull","cookies","isNil","value","expires","domain","cookiePath","notEmpty","cookieValue","Date","isString","setHeader","lang","setCookie","method","notString","toUpperCase","localizationStrategy","getApplication","getService","getDefaultCulture","getCookie","params","langs","length","obj","find","getCultures","x","csrfToken","csrfCookieToken","csrfRequestToken","JSON","decrypt","e","application","valid","tokenExpiration","key","hasOwnProperty","timestamp","date","diff","Math","abs","config","settings","auth","parseInt","text","lib","warn","getLocaleString","getCulture","fn","callback","interactiveUser","_unattended","call","err","getConfiguration","account","unattendedExecutionAccount","user","authenticationType","assign"],"mappings":"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","file":"context.js","sourcesContent":["/**\n * @license\n * MOST Web Framework 2.0 Codename Blueshift\n * Copyright (c) 2014, Kyriakos Barbounakis k.barbounakis@gmail.com\n *                     Anthi Oikonomou anthioikonomou@gmail.com\n *\n * Use of this source code is governed by an BSD-3-Clause license that can be\n * found in the LICENSE file at https://themost.io/license\n */\n'use strict';\nimport {_} from 'lodash';\nimport url from 'url';\nimport path from 'path';\nimport {HttpViewContext} from './mvc';\nimport {Args,TraceUtils} from '@themost/common/utils';\nimport {HttpBadRequestError} from '@themost/common/errors';\nimport {LocalizationStrategy} from './localization';\n\nfunction parseCookies(request) {\n    let list = {};\n    if (request && request.headers && request.headers.cookie) {\n        let rc = request.headers.cookie;\n        if (!_.isEmpty(rc)) {\n            _.forEach(rc.split(';'), (cookie) => {\n                let parts = cookie.split('=');\n                list[parts.shift().trim()] = unescape(parts.join('='));\n            });\n        }\n    }\n    return list;\n}\n\nconst cultureProperty = Symbol('culture');\nconst applicationProperty = Symbol('application');\n\n/**\n * @class\n * @property {*} params\n * @property {ClientRequest} request - Gets or sets the HTTP request of the current context\n * @property {ServerResponse} response - Gets or sets the HTTP response of the current context\n * @augments HttpContext\n */\nexport class HttpContext {\n    /**\n     *\n     * @constructor\n     * @param {HttpApplication2} app\n     * @param {ClientRequest} request\n     * @param {ServerResponse} response\n     */\n    constructor(app, request, response) {\n        this[applicationProperty] = app;\n        /**\n         * Gets or sets the HTTP request of the current context\n         * @type {ClientRequest}\n         */\n        this.request = request;\n        /**\n         * Gets or sets the HTTP response of the current context\n         * @type {ServerResponse}\n         */\n        this.response = response;\n    }\n\n    getApplication() {\n        return this[applicationProperty];\n    }\n\n    /**\n     * Gets the MIME extension of the current HTTP request\n     * @returns {*}\n     */\n    getFormat() {\n        let uri = url.parse(this.request.url);\n        let result = path.extname(uri.pathname);\n        if (result) {\n            return result.substr(1).toLowerCase();\n        }\n        else {\n            //get mime type\n            let mime = self.mime;\n            if (mime) {\n                //and return the extension associated with this mime\n                return mime.extension.substr(1).toLowerCase();\n            }\n        }\n    }\n\n    /**\n     * Creates a new instance of HttpViewContext class based on this HttpContext instance.\n     * @returns {HttpViewContext}\n     */\n    createViewContext() {\n        return new HttpViewContext(this);\n    }\n\n    /**\n     * Gets an HTTP request cookie with the specified name\n     * @param {string} name\n     * @returns {*}\n     */\n    getCookie(name) {\n        Args.notNull(this.request,\"HTTP Request\");\n        const cookies = parseCookies(this.request);\n        if (_.isNil(cookies)) { return; }\n        return cookies[name];\n    }\n\n    /**\n     * Sets a cookie with the specified name and value. If the value is missing or is null the cookie will be removed.\n     * @param {string} name\n     * @param {*=} value\n     * @param {Date=} expires\n     * @param {string=} domain\n     * @param {string=} cookiePath\n     */\n    setCookie(name, value, expires, domain, cookiePath) {\n        Args.notEmpty(name,'Name');\n        Args.notNull(this.response,'HTTP Response');\n        let cookieValue;\n        if (!_.isNil(value)) {\n            cookieValue = `{name}={value.toString()}`;\n            if (expires instanceof Date)\n                cookieValue += `;expires={expires.toUTCString()}`;\n        }\n        else {\n            cookieValue = `{name}=;expires={new Date('1970-01-01').toUTCString()}`;\n        }\n        //set default cookie path to root\n        cookiePath = cookiePath || '/';\n        //set cookie domain\n        if (_.isString(domain))\n            cookieValue += `;domain={domain}`;\n        //set cookie path\n        if (_.isString(cookiePath))\n            cookieValue += `;path={cookiePath}`;\n        //set cookie\n        this.response.setHeader('Set-Cookie',cookieValue);\n    }\n\n    /**\n     * Set a permanent cookie for user preferred language\n     * @param lang - A string which represents the user preferred language e.g. en-US, en-GB etc\n     */\n    setLangCookie(lang) {\n        this.setCookie(\".LANG\", lang);\n    }\n\n    /**\n     * Checks whether the HTTP method of the current request is equal or not to the given parameter.\n     * @param {string} method - The HTTP method (GET, POST, PUT, DELETE, OPTIONS, HEAD)\n     * */\n    is(method) {\n        Args.notNull(this.request,'HTTP Request');\n        if (_.isNil(method)) { return false; }\n        Args.notString(this.request,'HTTP Method');\n        return (this.request.method.toUpperCase() == method.toUpperCase());\n    }\n    /**\n     * Gets the current culture\n     */\n    getCulture() {\n        if (this[cultureProperty])\n            return this[cultureProperty];\n        /**\n         * @type {LocalizationStrategy}\n         */\n        const localizationStrategy = this.getApplication().getService(LocalizationStrategy);\n        if (_.isNil(localizationStrategy)) {\n            return 'en-us';\n        }\n        let lang = localizationStrategy.getDefaultCulture();\n        //1. Check HTTP cookie .LANG value\n        if (typeof this.getCookie(\".LANG\") === \"string\") {\n            lang = this.getCookie(\".LANG\");\n        }\n        //2. Check [lang] HTTP request param\n        else if (this.params && this.params.lang) {\n            lang = this.params.lang;\n        }\n        //2. Check request HTTP header [accept-language]\n        else if (this.request && this.request.headers && this.request.headers['accept-language']) {\n            const langs = this.request.headers['accept-language'].split(';');\n            if (langs.length>0) {\n                lang = langs[0].split(',')[0] || localizationStrategy.getDefaultCulture();\n            }\n        }\n        if (lang) {\n            //search application cultures\n            const obj = _.find(localizationStrategy.getCultures(), function(x) {\n                return (x == lang.toLowerCase()) || (x.substr(0,2) == lang.toLowerCase().substr(0,2));\n            });\n            //if user culture is valid for this application\n            if (obj) {\n                //set context culture\n                this[cultureProperty]=obj;\n                return this[cultureProperty];\n            }\n        }\n        //otherwise use default culture\n        this[cultureProperty] = localizationStrategy.getDefaultCulture();\n        return this[cultureProperty];\n    }\n\n    /**\n     * Sets the current culture\n     * @param value\n     */\n    setCulture(value) {\n        Args.notEmpty(value,'culture');\n        this[cultureProperty] = value;\n    }\n\n    /**\n     * Performs cross-site request forgery validation against the specified token\n     * @param {string=} csrfToken\n     */\n    validateAntiForgeryToken(csrfToken) {\n        const self = this;\n        if (typeof csrfToken === 'undefined') {\n            //try to get token from params\n            if (typeof self.params !== 'undefined')\n                csrfToken = self.params['_CSRFToken'];\n        }\n        if (typeof csrfToken !== 'string')\n            throw new HttpBadRequestError('Bad request. Invalid cross-site request forgery token.');\n        if (csrfToken.length==0)\n            throw new HttpBadRequestError('Bad request. Empty cross-site request forgery token.');\n            const cookies = self.cookies;\n            let csrfCookieToken;\n            let csrfRequestToken;\n            if (cookies['.CSRF']) {\n                //try to decrypt cookie token\n                try {\n                    csrfCookieToken = JSON.parse(self.getApplication().decrypt(cookies['.CSRF']));\n                }\n                catch(e) {\n                    throw new HttpBadRequestError('Bad request.Invalid cross-site request forgery data.');\n                }\n                //then try to decrypt the token provided\n                try {\n                    csrfRequestToken = JSON.parse(self.application.decrypt(csrfToken));\n                }\n                catch(e) {\n                    throw new HttpBadRequestError('Bad request.Invalid cross-site request forgery data.');\n                }\n                if ((typeof csrfCookieToken === 'object') && (typeof csrfRequestToken === 'object')) {\n\n                    let valid = true, tokenExpiration = 60;\n                    //1. validate token equality\n                    for(const key in csrfCookieToken) {\n                        if (csrfCookieToken.hasOwnProperty(key)) {\n                            if (csrfCookieToken[key]!==csrfRequestToken[key]) {\n                                valid = false;\n                                break;\n                            }\n                        }\n                    }\n                    if (valid==true) {\n                        //2. validate timestamp\n                        const timestamp = new Date(csrfCookieToken.date);\n                        const diff = Math.abs((new Date())-timestamp);\n                        if (diff<0) {\n                            valid=false;\n                        }\n                        if (valid) {\n                            if (self.application.config.settings)\n                                if (self.application.config.settings.auth)\n                                    if (self.application.config.settings.auth['csrfExpiration'])\n                                        tokenExpiration = parseInt(self.application.config.settings.auth['csrfExpiration']);\n                            if (diff>tokenExpiration*60*1000)\n                                valid=false;\n                        }\n                    }\n                    if (valid)\n                        return;\n\n                }\n                throw new HttpBadRequestError('Bad request. A cross-site request forgery was detected.');\n            }\n            else {\n                throw new HttpBadRequestError('Bad request.Missing cross-site request forgery data.');\n            }\n    }\n\n    /**\n     * Translates the given string to the language specified in this context\n     * @param {string} text - The string to translate\n     * @param {string=} lib - A string that represents the library which contains the source string. This arguments is optional. If this argument is missing, then the operation will use the default (global) library.\n     * @returns {*}\n     */\n    getLocaleString(text, lib) {\n        /**\n         * @type {LocalizationStrategy}\n         */\n        const localizationStrategy = this.getApplication().getService(LocalizationStrategy);\n        if (_.isNil(localizationStrategy)) {\n            TraceUtils.warn('The current application does not have a valid localization strategy. Define one in order to properly use localization methods.');\n            return text;\n        }\n        localizationStrategy.getLocaleString(this.getCulture(),text,lib);\n    }\n\n    /**\n     * Executes the specified code in unattended mode.\n     * @param {Function} fn\n     * @param {Function} callback\n     */\n    unattended(fn, callback) {\n        const self = this;\n        let interactiveUser;\n        callback = callback || function() {};\n        fn = fn || function() {};\n        if (self._unattended) {\n            try {\n                fn.call(self, function(err, result) {\n                    callback(err, result);\n                });\n            }\n            catch(e) {\n                callback(e);\n            }\n            return;\n        }\n        //get unattended execution account\n        const config = self.getApplication().getConfiguration();\n        config.settings.auth = config.settings.auth || {};\n        const account = config.settings.auth.unattendedExecutionAccount;\n        //get interactive user\n        if (this.user) {\n            interactiveUser = { name:this.user.name,authenticationType: this.user.authenticationType };\n            //setting interactive user\n            self.interactiveUser = interactiveUser;\n        }\n        if (account) {\n            self.user = { name:account, authenticationType:'Basic' };\n        }\n        try {\n            self._unattended = true;\n            fn.call(self, function(err, result) {\n                //restore user\n                if (interactiveUser) {\n                    self.user = _.assign({ }, interactiveUser);\n                }\n                delete self.interactiveUser;\n                delete self._unattended;\n                callback(err, result);\n            });\n        }\n        catch(e) {\n            //restore user\n            if (interactiveUser) {\n                self.user = _.assign({ }, interactiveUser);\n            }\n            delete self.interactiveUser;\n            delete self._unattended;\n            callback(e);\n        }\n    }\n\n}"]}