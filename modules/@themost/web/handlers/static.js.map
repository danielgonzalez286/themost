{"version":3,"sources":["static.es6"],"names":["StaticHandler","context","callback","call","filePath","application","mapPath","request","url","exists","stat","err","stats","isFile","currentHandler","currentExecutionPath","currentExecutionFileStats","e","executionPath","requestETag","headers","md5","createHash","update","mtime","toString","responseETag","digest","log","headerNames","response","origin","setHeader","prototype","preflightRequest","is","writeHead","end","extensionName","extname","mimes","config","contentType","contentEncoding","mime","filter","x","extension","type","encoding","source","createReadStream","pipe","on"],"mappings":"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","file":"static.js","sourcesContent":["/**\n * @license\n * MOST Web Framework 2.0 Codename Blueshift\n * Copyright (c) 2014, Kyriakos Barbounakis k.barbounakis@gmail.com\n *                     Anthi Oikonomou anthioikonomou@gmail.com\n *\n * Use of this source code is governed by an BSD-3-Clause license that can be\n * found in the LICENSE file at https://themost.io/license\n */\n'use strict';\nimport {HttpServerError,HttpNotFoundError,HttpForbiddenError} from '@themost/common/errors';\nimport {TraceUtils} from '@themost/common/utils';\nimport fs from 'fs';\nimport path from 'path';\nimport crypto from 'crypto';\n\n/**\n * @classdesc Static File Handler\n * @class\n * @augments HttpHandler\n */\nexport default class StaticHandler {\n    /**\n     *\n     * @param {HttpContext} context\n     * @param {Function} callback\n     */\n    validateRequest(context, callback) {\n        callback = callback || function() {};\n        callback.call(context);\n    }\n\n    /**\n     *\n     * @param {HttpContext} context\n     * @param {Function} callback\n     */\n    mapRequest(context, callback) {\n        callback = callback || function() {};\n        try {\n            //get file path\n            const filePath = context.application.mapPath('/app' + context.request.url);\n            fs.exists(filePath, function(exists) {\n               if (!exists) {\n                   callback(null);\n               }\n               else {\n                   fs.stat(filePath, function(err, stats) {\n                       if (err) {\n                           callback(err);\n                       }\n                       else {\n                           //if file exists\n                           if (stats && stats.isFile()) {\n                               //set request current handler\n                               context.request.currentHandler = new StaticHandler();\n                               //set current execution path\n                               context.request.currentExecutionPath = filePath;\n                               //set file stats\n                               context.request.currentExecutionFileStats = stats;\n                           }\n                           callback(null);\n                       }\n                   });\n               }\n            });\n        } catch (e) {\n            callback(e);\n        }\n    }\n\n    unmodifiedRequest(context, executionPath, callback) {\n        try {\n            const requestETag = context.request.headers['if-none-match'];\n            if (typeof requestETag === 'undefined' || requestETag == null) {\n                callback(null, false);\n                return;\n            }\n            fs.exists(executionPath, function(exists) {\n                try {\n                    if (exists) {\n                        fs.stat(executionPath, function(err, stats) {\n                            if (err) {\n                                callback(err);\n                            }\n                            else {\n                                if (!stats.isFile()) {\n                                    callback(null, false);\n                                }\n                                else {\n                                    //validate if-none-match\n                                    const md5 = crypto.createHash('md5');\n                                    md5.update(stats.mtime.toString());\n                                    const responseETag = md5.digest('base64');\n                                    return callback(null, (requestETag==responseETag));\n                                }\n                            }\n                        });\n                    }\n                    else {\n                        callback(null, false);\n                    }\n                }\n                catch (e) {\n                    TraceUtils.log(e);\n                    callback(null, false);\n                }\n            });\n        }\n        catch (e) {\n            TraceUtils.log(e);\n            callback(null, false);\n        }\n    }\n\n    /**\n     *\n     * @param {HttpContext} context\n     * @param {Function} callback\n     */\n    preflightRequest(context, callback) {\n        try {\n\n            if (context && (context.request.currentHandler instanceof StaticHandler)) {\n                const headerNames = context.response[\"_headerNames\"] || { };\n                if (typeof headerNames[\"access-control-allow-origin\"] === 'undefined') {\n                    if (context.request.headers.origin) {\n                        context.response.setHeader(\"Access-Control-Allow-Origin\", context.request.headers.origin);\n                    }\n                    else {\n                        context.response.setHeader(\"Access-Control-Allow-Origin\", \"*\");\n                    }\n                }\n                if (typeof headerNames[\"access-control-allow-headers\"] === 'undefined')\n                    context.response.setHeader(\"Access-Control-Allow-Headers\", \"Origin, X-Requested-With, Content-Type, Content-Language, Accept, Accept-Language, Authorization\");\n                if (typeof headerNames[\"access-control-allow-credentials\"] === 'undefined')\n                    context.response.setHeader(\"Access-Control-Allow-Credentials\", \"true\");\n                if (typeof headerNames[\"access-control-allow-methods\"] === 'undefined')\n                    context.response.setHeader(\"Access-Control-Allow-Methods\", \"GET, OPTIONS\");\n            }\n            return callback();\n        }\n        catch(e) {\n            callback(e);\n        }\n\n    }\n\n    /**\n     * @param {HttpContext} context\n     * @param {Function} callback\n     */\n    postMapRequest(context, callback) {\n        return StaticHandler.prototype.preflightRequest.call(this, context, callback);\n    }\n\n    /**\n     * @param {HttpContext} context\n     * @param {Function} callback\n     */\n    processRequest(context, callback) {\n        callback = callback || function() {};\n        try {\n            if (context.is('OPTIONS')) {\n                //do nothing\n                return callback();\n            }\n                //get current execution path and validate once again file presence and MIME type\n            const stats = context.request.currentExecutionFileStats;\n            if (typeof stats === 'undefined' || stats == null) {\n                callback(new HttpServerError('Invalid request handler.'));\n                return;\n            }\n            if (!stats.isFile()) {\n                return callback(new HttpNotFoundError());\n            }\n            else {\n                //get if-none-match header\n                const requestETag = context.request.headers['if-none-match'];\n                //generate responseETag\n                const md5 = crypto.createHash('md5');\n                md5.update(stats.mtime.toString());\n                const responseETag = md5.digest('base64');\n                if (requestETag)\n                    if (requestETag==responseETag) {\n                        //context.response.writeHead(304, { 'Last-Modified':stats.mtime.toUTCString() });\n                        context.response.writeHead(304, { });\n                        context.response.end();\n                        return callback.call(context);\n                    }\n                //get file extension\n                const extensionName  = path.extname(context.request.currentExecutionPath);\n                //get MIME collection\n                const mimes = context.application.config.mimes;\n                let contentType = null, contentEncoding=null;\n                //find MIME type by extension\n                const mime =mimes.filter(function(x) { return x.extension==extensionName; })[0];\n                if (mime) {\n                    contentType = mime.type;\n                    if (mime.encoding)\n                        contentEncoding = mime.encoding;\n                }\n                //throw exception (MIME not found or access denied)\n                if (contentType==null) {\n                    callback(new HttpForbiddenError())\n                }\n                else {\n                    //create stream\n                    const source = fs.createReadStream(context.request.currentExecutionPath);\n                    //write headers\n                    context.response.writeHead(200, {'Content-Type': contentType + (contentEncoding ? ';charset=' + contentEncoding : ''), 'ETag' : responseETag});\n                    //response file\n                    source.pipe(context.response);\n                    //handle end\n                    source.on('end', function() {\n                        callback();\n                    });\n                    //handle error\n                    source.on('error', function(err) {\n                        callback(err);\n                    });\n                }\n            }\n            }\n            catch (e) {\n            callback.call(context, e);\n        }\n    }\n}\n\n\n\n"]}