{"version":3,"sources":["formatters.es6"],"names":["HttpApplicationService","AbstractClassError","AbstractMethodError","Args","_","Q","accepts","xml","path","url","formattersProperty","Symbol","FormatterStrategy","app","check","new","target","formatterCtor","push","index","splice","find","x","context","isMatch","DefaultFormatterStrategy","add","HtmlOutputFormatter","JsonOutputFormatter","XmlOutputFormatter","formatters","mimeType","getApplication","getMimeType","extname","parse","request","pathname","types","map","getType","accept","acceptedType","type","isNil","extension","substr","OutputFormatter","data","reject","_json_ignore_null_replacer","key","value","undefined","options","nfbind","callback","response","writeHead","Error","status","getContentType","ignoreNullValues","write","JSON","stringify","serialize","outerXML","statusCode","message","HttpViewResult","require","result","execute","err"],"mappings":"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","file":"formatters.js","sourcesContent":["/**\n * @license\n * MOST Web Framework 2.0 Codename Blueshift\n * Copyright (c) 2017, THEMOST LP All rights reserved\n *\n * Use of this source code is governed by an BSD-3-Clause license that can be\n * found in the LICENSE file at https://themost.io/license\n */\nimport 'source-map-support/register';\nimport {HttpApplicationService} from \"./interfaces\";\nimport {AbstractClassError, AbstractMethodError} from \"@themost/common/errors\";\nimport {Args} from \"@themost/common/utils\";\nimport {_} from 'lodash';\nimport Q from 'q';\nimport accepts from 'accepts';\nimport xml from 'most-xml';\nimport path from 'path';\nimport url from 'url';\n\nconst formattersProperty = Symbol('formatters');\n\nexport class FormatterStrategy extends HttpApplicationService {\n    constructor(app) {\n        Args.check(new.target !== FormatterStrategy, new AbstractClassError());\n        super(app);\n        this[formattersProperty] = [ ];\n    }\n\n    /**\n     * Adds a formatter into the collection of application formatters\n     * @param {Function} formatterCtor\n     */\n    add(formatterCtor) {\n        Args.check(typeof formatterCtor === 'function', 'Formatter constructor mub be a function');\n        this[formattersProperty].push(new formatterCtor());\n    }\n\n    /**\n     * Inserts a formatter into the collection at the specified index\n     * @param {number} index\n     * @param {Function} formatterCtor\n     */\n    insert(index, formatterCtor) {\n        Args.check(typeof formatterCtor === 'function', 'Formatter constructor mub be a function');\n        this[formattersProperty].splice(index, 0, new formatterCtor());\n    }\n\n    /**\n     * Gets a formatter based on the given type\n     * @param {Function} formatterCtor\n     */\n    get(formatterCtor) {\n        Args.check(typeof formatterCtor === 'function', 'Formatter constructor mub be a function');\n        return _.find(this[formattersProperty], function(x) {\n            return x instanceof formatterCtor;\n        });\n    }\n\n    /**\n     * Finds a formatter for the given HTTP context\n     * @param {HttpContext} context\n     * @returns {OutputFormatter}\n     */\n    find(context) {\n        return _.find(this[formattersProperty], function(x) {\n            return x.isMatch(context);\n        });\n    }\n\n}\n\nexport class DefaultFormatterStrategy extends FormatterStrategy {\n    constructor(app) {\n        super(app);\n        this.add(HtmlOutputFormatter);\n        this.add(JsonOutputFormatter);\n        this.add(XmlOutputFormatter);\n    }\n\n    /**\n     * Finds a formatter for the given HTTP context\n     * @param context\n     * @returns {OutputFormatter}\n     */\n    find(context) {\n        const formatters = this[formattersProperty];\n        const mimeType = context.getApplication().getMimeType(path.extname(url.parse(context.request.url).pathname));\n        if (typeof mimeType === 'undefined') {\n            //get available formatters (as array of types)\n            const types = _.map(this[formattersProperty], (x) => {\n                return x.getType();\n            });\n            let accept = accepts(context.request);\n            let acceptedType = accept.type(types);\n            if (_.isNil(acceptedType)) { return; }\n            return _.find(this[formattersProperty], (x)=> {\n                return x.getType()===acceptedType;\n            })\n        }\n        return _.find(this[formattersProperty], (x)=> {\n            if (mimeType) {\n                return x.getType()===mimeType.extension.substr(1);\n            }\n            return false;\n        });\n    }\n\n}\n/**\n * @class\n */\nexport class OutputFormatter {\n    constructor() {\n        Args.check(new.target !== OutputFormatter, new AbstractClassError());\n    }\n    /**\n     * Gets the media type associated with an output formatter\n     * @returns {string}\n     */\n    getMediaType() {\n        throw new AbstractMethodError();\n    }\n\n    /**\n     * Gets the content type associated with an output formatter\n     * @returns {string}\n     */\n    getContentType() {\n        throw new AbstractMethodError();\n    }\n\n    /**\n     * Gets the type associated with an output formatter\n     * @returns {string}\n     */\n    getType() {\n        throw new AbstractMethodError();\n    }\n\n    /**\n     * Check if the given HTTP context accepts formatting\n     * @param {HttpContext} context\n     */\n    isMatch(context) {\n        let accept = accepts(context.request);\n        return accept.type([this.getType()])\n    }\n\n    /**\n     * Executes formatter against the given HTTP context\n     * @param {HttpContext} context\n     * @param {*} data\n     * @returns {Promise}\n     */\n    execute(context, data) {\n        return Q.reject(new AbstractMethodError());\n    }\n}\n\n/**\n * @param {string} key\n * @param {*} value\n * @returns {*}\n * @private\n */\nfunction _json_ignore_null_replacer(key, value) {\n    if (value === null)\n        return undefined;\n    return value;\n}\n\n\nexport class JsonOutputFormatter extends OutputFormatter {\n\n    constructor() {\n        super();\n        this.options = {\n            \"ignoreNullValues\": true\n        }\n    }\n    /**\n     * Gets the media type associated with an output formatter\n     * @returns {string}\n     */\n    getMediaType() {\n        return 'application/json';\n    }\n\n    /**\n     * Gets the content type associated with an output formatter\n     * @returns {string}\n     */\n    getContentType() {\n        return 'application/json;charset=utf-8';\n    }\n\n    /**\n     * Gets the type associated with an output formatter\n     * @returns {string}\n     */\n    getType() {\n        return 'json';\n    }\n\n    /**\n     *\n     * @param {HttpContext} context\n     * @param {*} data\n     * @returns {Promise}\n     */\n    execute(context, data) {\n        return Q.nfbind((callback) => {\n            if (_.isNil(data)) {\n                //return 204 (no content)\n                context.response.writeHead(204);\n                return callback();\n            }\n            if (data instanceof Error) {\n                //send error in JSON format\n                context.response.writeHead(data.status || 500, { \"Content-Type\": this.getContentType()});\n            }\n            else {\n                context.response.writeHead(200, { \"Content-Type\": this.getContentType()});\n            }\n            if (this.options.ignoreNullValues) {\n                context.response.write(JSON.stringify(data,_json_ignore_null_replacer), 'utf8');\n            }\n            else {\n                context.response.write(JSON.stringify(data), 'utf8');\n            }\n            return callback();\n        })();\n    }\n}\n\nexport class XmlOutputFormatter extends OutputFormatter {\n\n    constructor() {\n        super();\n        this.options = {\n            \"ignoreNullValues\": true\n        }\n    }\n    /**\n     * Gets the media type associated with an output formatter\n     * @returns {string}\n     */\n    getMediaType() {\n        return 'application/xml';\n    }\n    /**\n     * Gets the type associated with an output formatter\n     * @returns {string}\n     */\n    getType() {\n        return 'xml';\n    }\n\n    /**\n     * Gets the content type associated with an output formatter\n     * @returns {string}\n     */\n    getContentType() {\n        return 'application/xml;charset=utf-8';\n    }\n\n    /**\n     * Executes formatter against the given HTTP context\n     * @param {HttpContext} context\n     * @param {*} data\n     * @returns {Promise}\n     */\n    execute(context, data) {\n        return Q.nfbind((callback) => {\n            if (_.isNil(data)) {\n                //return 204 (no content)\n                context.response.writeHead(204);\n                return callback();\n            }\n            if (data instanceof Error) {\n                //send error in JSON format\n                context.response.writeHead(data.status || 500, { \"Content-Type\": this.getContentType()});\n            }\n            else {\n                context.response.writeHead(200, { \"Content-Type\": this.getContentType()});\n            }\n            context.response.write(xml.serialize(data).outerXML(), 'utf8');\n            return callback();\n        })();\n    }\n}\n\nexport class HtmlOutputFormatter extends OutputFormatter {\n\n    constructor() {\n        super();\n        this.options = {\n            \"ignoreNullValues\": true\n        }\n    }\n    /**\n     * Gets the media type associated with an output formatter\n     * @returns {string}\n     */\n    getMediaType() {\n        return 'text/html';\n    }\n    /**\n     * Gets the type associated with an output formatter\n     * @returns {string}\n     */\n    getType() {\n        return 'html';\n    }\n\n    /**\n     * Gets the content type associated with an output formatter\n     * @returns {string}\n     */\n    getContentType() {\n        return 'text/html;charset=utf-8';\n    }\n\n    /**\n     * Executes formatter against the given HTTP context\n     * @param {HttpContext} context\n     * @param {*} data\n     * @returns {Promise}\n     */\n    execute(context, data) {\n        return Q.nfbind((callback) => {\n            if (_.isNil(data)) {\n                //return 204 (no content)\n                context.response.writeHead(204);\n                return callback();\n            }\n            if (data instanceof Error) {\n                const statusCode = data.status || 500;\n                //send error in JSON format\n                context.response.writeHead(statusCode, { \"Content-Type\": this.getContentType()});\n                context.response.write(statusCode + ' ' + data.message, 'utf8');\n            }\n            else {\n                const HttpViewResult = require('./mvc').HttpViewResult;\n                const result = new HttpViewResult(null, data);\n                return result.execute(context, function(err) {\n                    return callback(err);\n                });\n            }\n            return callback();\n        })();\n    }\n}"]}