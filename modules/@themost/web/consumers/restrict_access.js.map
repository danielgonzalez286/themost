{"version":3,"sources":["restrict_access.es6"],"names":["HttpUnauthorizedError","HttpBadRequestError","TraceUtils","HttpApplicationService","HttpNextResult","HttpConsumer","_","Q","url","LocationSetting","applicationProperty","Symbol","RestrictAccessService","app","requestURL","isNil","uri","parse","conf","getApplication","getConfiguration","isObject","settings","auth","isArray","locations","i","length","location","test","path","pathname","indexOf","replace","allow","err","reject","isNotRestricted","then","res","RestrictHandler","context","callback","is","user","name","svc","getService","isRestricted","request","catch","log","e","RestrictAccessConsumer","handler","nfbind","authorizeRequest","create","toPromise"],"mappings":"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","file":"restrict_access.js","sourcesContent":["/**\n * @license\n * MOST Web Framework 2.0 Codename Blueshift\n * Copyright (c) 2014, Kyriakos Barbounakis k.barbounakis@gmail.com\n *                     Anthi Oikonomou anthioikonomou@gmail.com\n *\n * Use of this source code is governed by an BSD-3-Clause license that can be\n * found in the LICENSE file at https://themost.io/license\n */\n'use strict';\nimport 'source-map-support/register';\nimport {HttpUnauthorizedError,HttpBadRequestError} from '@themost/common/errors';\nimport {TraceUtils} from '@themost/common/utils';\nimport {HttpApplicationService} from '../interfaces';\nimport {HttpNextResult} from '../results';\nimport {HttpConsumer} from '../consumers';\nimport {_} from 'lodash';\nimport Q from 'q';\nimport url from 'url';\n/**\n * @class\n * @property {string} description - Gets or sets a string that represents the description of this object\n * @property {*} path - Gets or sets a string that represents the target path associated with access settings.\n * @property {string} allow - Gets or sets a comma delimited string that represents the collection of users or groups where this access setting will be applied. A wildcard (*) may be used.\n * @property {string} deny - Gets or sets a string that represents the collection of users or groups where this access setting will be applied. A wildcard (*) may be used.\n */\nclass LocationSetting {\n    constructor() {\n        //\n    }\n}\n\nconst applicationProperty = Symbol('application');\n\n\n/**\n * @class\n */\nexport class RestrictAccessService extends HttpApplicationService{\n    /**\n     * @param {HttpApplication} app\n     */\n    constructor(app) {\n       super(app);\n    }\n\n    /**\n     * @param {string} requestURL\n     * @returns {Promise}\n     */\n    isNotRestricted(requestURL) {\n       try {\n           if (_.isNil(requestURL)) {\n               return Q(true);\n           }\n           const uri = url.parse(requestURL);\n           const conf = this.getApplication().getConfiguration();\n           if (_.isObject(conf.settings)\n               && _.isObject(conf.settings.auth)\n               && _.isArray(conf.settings.auth.locations)) {\n               /**\n                * @type {Array}\n                */\n               const locations = conf.settings.auth.locations;\n               for (let i = 0; i < locations.length; i++) {\n                   /**\n                    * @type {*|LocationSetting}\n                    */\n                   const location = locations[i];\n                   if (/\\*$/.test(location.path)) {\n                       //wildcard search /something/*\n                       if ((uri.pathname.indexOf(location.path.replace(/\\*$/,''))===0) && (location.allow==='*')) {\n                           return Q(true);\n                       }\n                   }\n                   else {\n                       if ((uri.pathname===location.path) && (location.allow==='*')) {\n                           return Q(true);\n                       }\n                   }\n               }\n               return Q(false);\n           }\n           return Q(true);\n       }\n       catch(err) {\n           return Q.reject(err);\n       }\n    }\n    /**\n     * @param {string} requestURL\n     * @returns {Promise}\n     */\n    isRestricted(requestURL) {\n        return this.isNotRestricted(requestURL).then((res)=> {\n           return Q(!res);\n        });\n    }\n}\n\n/**\n * @class\n * @augments HttpHandler\n */\nclass RestrictHandler {\n    /**\n     * Authenticates an HTTP request and sets user or anonymous identity.\n     * @param {HttpContext} context\n     * @param {Function} callback\n     */\n    authorizeRequest(context, callback) {\n        try {\n            if (context.is('OPTIONS')) { return callback(); }\n            if (context.user.name==='anonymous')\n            {\n                /**\n                 * @type RestrictAccessService;\n                 */\n                const svc = context.getApplication().getService(RestrictAccessService);\n                if (_.isNil(svc)) {\n                    return callback();\n                }\n                svc.isRestricted(context.request.url).then((res)=> {\n                    if (res) {\n                        return callback(new HttpUnauthorizedError());\n                    }\n                    return callback();\n                }).catch((err)=> {\n                    TraceUtils.log(err);\n                    return callback(new HttpUnauthorizedError());\n                });\n            }\n            else {\n                callback();\n            }\n        }\n        catch (e) {\n            callback(e);\n        }\n    }\n}\n\nexport class RestrictAccessConsumer extends HttpConsumer {\n    constructor() {\n        super(function() {\n            /**\n             * @type {HttpContext}\n             */\n            const context = this;\n            try {\n                let handler = new RestrictHandler();\n                return Q.nfbind(handler.authorizeRequest)(context)\n                    .then(()=> {\n                        return HttpNextResult.create().toPromise();\n                    });\n            }\n            catch(err) {\n                return Q.reject(err);\n            }\n        });\n    }\n}"]}