{"version":3,"sources":["static.es6"],"names":["HttpServerError","HttpNotFoundError","HttpForbiddenError","TraceUtils","_","fs","url","path","crypto","HttpConsumer","Rx","HttpNextResult","HttpEndResult","StaticHandler","rootDir","whenDir","context","callback","uri","parse","request","pathname","isString","re","RegExp","escapeRegExp","test","replace","filePath","join","exists","stat","err","stats","isFile","currentHandler","currentExecutionPath","currentExecutionFileStats","executionPath","requestETag","headers","md5","createHash","update","mtime","toString","responseETag","digest","e","log","is","isNil","response","writeHead","end","extensionName","extname","contentType","contentEncoding","mime","getApplication","getConfiguration","getMimeType","type","encoding","source","createReadStream","pipe","on","StaticContentConsumer","handler","Observable","bindNodeCallback","mapRequest","bind","flatMap","res","processRequest","create","toObservable","MapStaticContentConsumer"],"mappings":"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","file":"static.js","sourcesContent":["/**\n * @license\n * MOST Web Framework 2.0 Codename Blueshift\n * Copyright (c) 2014, Kyriakos Barbounakis k.barbounakis@gmail.com\n *                     Anthi Oikonomou anthioikonomou@gmail.com\n *\n * Use of this source code is governed by an BSD-3-Clause license that can be\n * found in the LICENSE file at https://themost.io/license\n */\n'use strict';\nimport 'source-map-support/register';\nimport {HttpServerError,HttpNotFoundError,HttpForbiddenError} from '@themost/common/errors';\nimport {TraceUtils} from '@themost/common/utils';\nimport {_} from 'lodash';\nimport fs from 'fs';\nimport url from 'url';\nimport path from 'path';\nimport crypto from 'crypto';\nimport {HttpConsumer} from '../consumers';\nimport Rx from 'rxjs';\nimport {HttpNextResult, HttpEndResult} from '../results';\n\n/**\n * @classdesc Default static content handler (as it has been implemented for version 1.x of MOST Web Framework)\n * @class\n * @private\n */\nclass StaticHandler {\n\n    /**\n     *\n     * @param {string=} rootDir\n     */\n    constructor(rootDir) {\n        this.rootDir = rootDir || './app';\n        this.whenDir =  '/';\n    }\n\n    /**\n     *\n     * @param {HttpContext} context\n     * @param {Function} callback\n     */\n    mapRequest(context, callback) {\n        callback = callback || function() {};\n        try {\n            let uri = url.parse(context.request.url).pathname;\n            if (_.isString(this.whenDir) && this.whenDir!='/') {\n                const re = new RegExp('^' + _.escapeRegExp(this.whenDir),'ig');\n                if (!re.test(uri)) {\n                    return callback(null, false);\n                }\n                else {\n                    uri = uri.replace(re,'');\n                }\n            }\n            const filePath = path.join(this.rootDir, uri);\n            fs.exists(filePath, function(exists) {\n                if (!exists) {\n                    return callback(null, false);\n                }\n                else {\n                    fs.stat(filePath, function(err, stats) {\n                        if (err) {\n                            return callback(err);\n                        }\n                        //if file exists\n                        if (stats && stats.isFile()) {\n                            //set request current handler\n                            context.request.currentHandler = new StaticHandler();\n                            //set current execution path\n                            context.request.currentExecutionPath = filePath;\n                            //set file stats\n                            context.request.currentExecutionFileStats = stats;\n                            //return true\n                            return callback(null, true);\n                        }\n                        return callback(null, false);\n                    });\n                }\n            });\n        } catch (err) {\n            return callback(err);\n        }\n    }\n\n    unmodifiedRequest(context, executionPath, callback) {\n        try {\n            const requestETag = context.request.headers['if-none-match'];\n            if (typeof requestETag === 'undefined' || requestETag == null) {\n                callback(null, false);\n                return;\n            }\n            fs.exists(executionPath, function(exists) {\n                try {\n                    if (exists) {\n                        fs.stat(executionPath, function(err, stats) {\n                            if (err) {\n                                callback(err);\n                            }\n                            else {\n                                if (!stats.isFile()) {\n                                    callback(null, false);\n                                }\n                                else {\n                                    //validate if-none-match\n                                    const md5 = crypto.createHash('md5');\n                                    md5.update(stats.mtime.toString());\n                                    const responseETag = md5.digest('base64');\n                                    return callback(null, (requestETag==responseETag));\n                                }\n                            }\n                        });\n                    }\n                    else {\n                        callback(null, false);\n                    }\n                }\n                catch (e) {\n                    TraceUtils.log(e);\n                    callback(null, false);\n                }\n            });\n        }\n        catch (e) {\n            TraceUtils.log(e);\n            callback(null, false);\n        }\n    }\n\n    /**\n     * @param {HttpContext} context\n     * @param {Function} callback\n     */\n    processRequest(context, callback) {\n        callback = callback || function() {};\n        try {\n            if (context.is('OPTIONS')) {\n                //do nothing\n                return callback();\n            }\n            //get current execution path and validate once again file presence and MIME type\n            const stats = context.request.currentExecutionFileStats;\n            if (_.isNil(stats)) {\n                return callback(new HttpServerError('Invalid request handler.'));\n            }\n            if (!stats.isFile()) {\n                return callback(new HttpNotFoundError());\n            }\n            else {\n                //get if-none-match header\n                const requestETag = context.request.headers['if-none-match'];\n                //generate responseETag\n                const md5 = crypto.createHash('md5');\n                md5.update(stats.mtime.toString());\n                const responseETag = md5.digest('base64');\n                if (requestETag)\n                    if (requestETag==responseETag) {\n                        //context.response.writeHead(304, { 'Last-Modified':stats.mtime.toUTCString() });\n                        context.response.writeHead(304, { });\n                        context.response.end();\n                        return callback();\n                    }\n                //get file extension\n                const extensionName  = path.extname(context.request.currentExecutionPath);\n                //get MIME collection\n                let contentType = null, contentEncoding=null;\n                //find MIME type by extension\n                const mime =context.getApplication().getConfiguration().getMimeType(extensionName);\n                if (mime) {\n                    contentType = mime.type;\n                    if (mime.encoding)\n                        contentEncoding = mime.encoding;\n                }\n                //throw exception (MIME not found or access denied)\n                if (contentType==null) {\n                    return callback(new HttpForbiddenError())\n                }\n                else {\n                    //create stream\n                    const source = fs.createReadStream(context.request.currentExecutionPath);\n                    //write headers\n                    context.response.writeHead(200, {'Content-Type': contentType + (contentEncoding ? ';charset=' + contentEncoding : ''), 'ETag' : responseETag});\n                    //response file\n                    source.pipe(context.response);\n                    //handle end\n                    source.on('end', function() {\n                        callback();\n                    });\n                    //handle error\n                    source.on('error', function(err) {\n                        callback(err);\n                    });\n                }\n            }\n        }\n        catch (err) {\n            return callback(err);\n        }\n    }\n}\n\n\nexport class StaticContentConsumer extends HttpConsumer {\n    /**\n     * @param {string=} rootDir\n     * @constructor\n     */\n    constructor(rootDir) {\n        super(function() {\n            /**\n             * @type {HttpContext}\n             */\n            const context = this;\n            try {\n                let handler = new StaticHandler(rootDir);\n                return Rx.Observable.bindNodeCallback(handler.mapRequest.bind(handler))(context)\n                    .flatMap((res) => {\n                        if (res) {\n                            return Rx.Observable.bindNodeCallback(handler.processRequest.bind(handler))(context);\n                        }\n                        return HttpNextResult.create().toObservable();\n                    });\n            }\n            catch(err) {\n                return Rx.Observable['throw'](err);\n            }\n        });\n    }\n}\n\nexport class MapStaticContentConsumer extends HttpConsumer {\n    /**\n     * @param {string=} whenDir\n     * @param {string=} rootDir\n     * @constructor\n     */\n    constructor(whenDir, rootDir) {\n        super(function() {\n            /**\n             * @type {HttpContext}\n             */\n            const context = this;\n            try {\n                let handler = new StaticHandler(rootDir);\n                handler.whenDir = whenDir;\n                return Rx.Observable.bindNodeCallback(handler.mapRequest.bind(handler))(context)\n                    .flatMap((res) => {\n                        if (res) {\n                            return Rx.Observable.bindNodeCallback(handler.processRequest.bind(handler))(context);\n                        }\n                        return HttpNextResult.create().toObservable();\n                    });\n            }\n            catch(err) {\n                return Rx.Observable['throw'](err);\n            }\n        });\n    }\n}\n\n\n"]}